{
  "num_total": 470,
  "num_groups": 267,
  "num_to_grade": 169,
  "num_parsed": 227,
  "num_failed": 40,
  "num_single": 231,
  "num_correct_output": 98,
  "num_runtime_event": 63,
  "group_lengths": [
    64,
    38,
    19,
    13,
    13,
    11,
    8,
    5,
    5,
    4,
    4,
    4,
    3,
    3,
    3,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
  ],
  "groups": [
    {
      "group": 0,
      "parsed": true,
      "num": 64,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "Node *n = first;\nint sum = 0;\nwhile (n)\n{\n  sum += n->datum;\n  n = n->next;\n}\nreturn sum;",
        "int total = 0;\nNode* node = first;\nwhile(node){\n    total += node->datum;\n    node = node->next;\n}\nreturn total;",
        "int count = 0;\nNode *node = first;\nwhile(node){\n  count += node->datum;\n  node = node->next;\n}\nreturn count;",
        "int sum = 0;\nNode *temp = first;\nwhile (temp) {\n    sum += temp->datum;\n    temp = temp->next;\n}\nreturn sum;",
        "int sum = 0;\nNode * temp = first;\nwhile(temp != 0){\n    sum += temp->datum;\n    temp = temp->next;\n}\nreturn sum;",
        "    Node * node = first;\n    int sum = 0;\n    while (node) {\n      sum += node->datum;\n      node = node->next;\n    }\n    return sum;",
        "int count = 0;\nNode *current = first;\nwhile(current != 0){\n    count += current->datum;\n    current = current->next;\n}\nreturn count;",
        "Node *cur = first;\nint sum = 0;\nwhile (cur){\n    sum += cur->datum;\n    cur = cur->next;\n}\nreturn sum;",
        "Node *node = first;\nint sum = 0;\nwhile(node){\n    sum += node->datum;\n    node = node->next;\n}\nreturn sum;",
        "int sum = 0;\n\nNode *current = first;\n\nwhile (current) {\n    sum += current->datum;\n    current = current->next;\n}\n\nreturn sum;",
        "Node *tem = first;\nint s = 0;\nwhile (tem != 0){\n    s += tem->datum;\n    tem = tem->next;\n}\nreturn s;",
        "int total = 0;\n\nNode* curr = first;\nwhile(curr) {\n    total += curr->datum;\n    curr = curr->next;\n}\n\nreturn total;",
        "Node* thisNode = first;\nint sum = 0;\nwhile(thisNode != 0) {\n    sum += thisNode->datum;\n    thisNode = thisNode->next;\n}\nreturn sum;",
        "Node *current = first;\nint s = 0;\nwhile(current != 0){\n  s += current->datum;\n  current = current->next;\n}\nreturn s;",
        "Node *n = first;\nint sum = 0;\nwhile (n != 0){\nsum += n->datum;\nn = n->next;\n}\nreturn sum;",
        "int sum = 0;\nNode * temp = first;\nwhile (temp != 0) {\n    sum += temp->datum;\n    temp = temp->next;\n}\nreturn sum;",
        "int sum = 0;\nNode *node = first;\nwhile (node){\n    sum += node->datum;\n    node = node->next;\n}\nreturn sum;",
        "int s = 0;\nNode *n = first;\n\nwhile(n) {\n    s +=  n->datum;\n    n = n->next;\n}\n\nreturn s;",
        "int total = 0;\n\nNode *n = first;\n\nwhile(n != 0){\n    total += n->datum;\n    n = n->next;\n}\n\nreturn total;",
        "int sum = 0;\nNode *current_node = first;\nwhile (current_node != 0)\n{\n    sum += current_node->datum;\n    current_node = current_node->next;\n}\nreturn sum;",
        "int total = 0;\nNode* starter = first;\nwhile(starter){\n    total += starter->datum;\n    starter = starter->next;\n}\nreturn total;",
        "Node *cur = first;\nint sum = 0;\n\nwhile(cur){\n    sum += cur->datum;\n    cur = cur->next;\n}\nreturn sum;",
        "Node* n = first;\nint sum = 0;\nwhile (n) {\n    sum += n->datum;\n    n = n->next; \n}\nreturn sum;",
        "Node * n= first;\nint sum =0;\nwhile(n!= 0){\n    sum+=n->datum;\n    n=n->next;\n}\nreturn sum;\n",
        "int sum = 0;\nNode* n = first;\nwhile (n)\n{\n\tsum += n->datum;\n\tn = n->next;\n}\nreturn sum;",
        "int s = 0; \nNode* ptr = first;\nwhile(ptr) {\n    s += ptr->datum;\n    ptr = ptr->next;\n}\nreturn s;",
        "int total = 0;\n      Node *current = first;\n\n      while(current){\n          total += current->datum;\n          current = current->next;\n      }\n\n      return total;",
        "Node *n = first;\nint sum = 0;\nwhile(n){\n    sum += n->datum;\n    n = n->next;\n}\nreturn sum;",
        "int s = 0;\nNode* cur = first;\nwhile(cur != 0) {\n    s += cur->datum;\n    cur = cur->next;\n}\nreturn s; ",
        "int sum = 0;\nNode *curr = first; \nwhile(curr){\n    sum += curr->datum;\n    curr = curr->next;\n}\nreturn sum;",
        "\t  Node* ptr = first;\n\t  int result = 0;\n\t  while(ptr != 0) {\n\t\t  result += ptr->datum;\n\t\t  ptr = ptr->next;\n\t  }\n\t  return result;",
        "Node* node = first;\nint total = 0;\nwhile (node != 0) {\n    total += node->datum;\n    node = node->next;\n    }\n    return total;",
        "int temp = 0;\nNode *n = first;\nwhile (n != 0) {\n    temp += n->datum;\n    n = n->next;\n}\nreturn temp;",
        "int i = 0;\nNode* npt = first;\nwhile(npt){\ni+= npt -> datum;\nnpt = npt -> next;\n}\nreturn i;\n ",
        "Node* current = first;\nint sum =0;\nwhile(current){\n    sum+= current->datum;\n    current = current->next;\n}\nreturn sum;",
        "Node *ptr = first;\nint sum = 0;\nwhile(ptr){\n    sum += ptr->datum;\n    ptr = ptr->next;\n}\nreturn sum;",
        "Node * temp = first;\nint count = 0;\n\nwhile (temp) {\n    count += temp->datum;\n    temp = temp->next;\n}\n\nreturn count;",
        "int sum = 0;\nNode *node = first;\nwhile(node != 0){\n    sum += node->datum;\n    node = node->next;\n}\nreturn sum;",
        "int sum = 0;\nNode * n = first;\nwhile (n != 0) {\n    sum += n->datum;\n    n = n->next;\n}\nreturn sum;",
        "Node *n = first;\nint sum = 0;\nwhile(n) {\n    sum += n->datum;\n    n = n->next;\n}\nreturn sum;",
        "int temp = 0;\nNode* ptr = first;\nwhile (ptr != 0) {\n    temp += ptr->datum;\n    ptr = ptr->next;\n}\nreturn temp;",
        "int sum = 0;\nNode *p = first;\nwhile (p) {\n    sum+= p->datum;\n    p = p->next;\n}\nreturn sum;",
        "int sum_num = 0;\nNode* temp = first;\nwhile(temp) {\n    sum_num += temp->datum;\n    temp = temp->next;\n}\nreturn sum_num;",
        "int curr_sum = 0;\nNode *current = first;\nwhile (current) {\n    curr_sum += current->datum;\n    current = current->next;\n}\nreturn curr_sum;",
        "int sum = 0;\nNode* curr_node = first;\nwhile(curr_node!=0){\n    sum+= curr_node->datum;\n    curr_node = curr_node->next;\n}\nreturn sum;",
        "int sum = 0;\nNode* ptr = first;\nwhile (ptr){\n    sum += ptr->datum;\n    ptr = ptr->next;\n    }\nreturn sum;",
        "Node* lookingAt = first;\nint sum=0;\nwhile(lookingAt != 0)\n{\n    sum += lookingAt->datum;\n    lookingAt=lookingAt->next;\n}\nreturn sum;\n",
        "\tint sum = 0;\n\tNode* node = first;\n\twhile (node) {\n\t\tsum += node->datum;\n\t\tnode = node->next;\n\t}\n\treturn sum;",
        "Node*sup = first; \nint sum = 0; \nwhile(sup){\n\tsum += sup->datum;\n\tsup = sup->next;\n}\nreturn sum;\n",
        "Node *new_node = first;\nint sum = 0;\nwhile(new_node){\n    sum += new_node->datum;\n    new_node = new_node->next;\n}\nreturn sum;",
        "Node * dummy = first;\nint s = 0;\nwhile (dummy){\n     s += dummy->datum;\n     dummy = dummy->next;\n}\nreturn s;\n",
        "int sum = 0; //create variable to keep track of sum\nNode* curNode = first; //create a node to increment through the list\nwhile(curNode != 0) { //while not at end\n    sum += curNode->datum; //add value from current node\n    curNode = curNode->next; //go to next node;\n}\nreturn sum;",
        "Node *start = first;\nint sum = 0;\nwhile (start != 0) {\n    sum += start->datum;\n    start = start->next;\n}\nreturn sum;",
        "int result = 0;\nNode* ptr = first;\nwhile (ptr != 0) {\n    result += ptr->datum;\n    ptr = ptr->next;\n}\nreturn result;",
        "Node* node = first;\nint sum = 0;\nwhile (node != 0) {\n\tsum += node->datum;\n\tnode = node->next;\n\t}\nreturn sum;",
        "Node *mover = first;\nint math = 0;\nwhile(mover){\n    math += mover->datum; //add the current datum to the sum\n    mover = mover->next;  //go to the next node\n}\nreturn math;//if list is empty, mover is 0, skips loop and returns 0",
        "Node *ptr = first;\nint sum = 0;\nwhile(ptr) {\n  sum += ptr->datum;\n  ptr = ptr->next;\n}\n\nreturn sum;",
        "int sum = 0;\nNode *curr_node = first;\nwhile (curr_node) {\n    sum += curr_node->datum;\n    curr_node = curr_node->next;\n}\n\nreturn sum;",
        "Node* ptr = first;\nint sum = 0;\nwhile (ptr){\n    sum += ptr->datum;\n    ptr = ptr->next;\n}\nreturn sum;",
        "int total = 0;\nNode *temp = first;\nwhile (temp != 0)\n{\n    total += temp->datum;\n    temp=temp->next;\n}\nreturn total;",
        "Node *head = first;\nint sum = 0;\nwhile(head != 0){\n    sum += head->datum;\n    head = head->next;\n}\nreturn sum;",
        "int sum = 0;\nNode *temp = first;\n\nwhile (temp){\n    sum += temp->datum;\n    temp = temp->next;\n}\n\nreturn sum;",
        "int total = 0;\nNode *curr = first;\nwhile (curr) {\n  total += curr->datum;\n  curr = curr->next;\n}\nreturn total;",
        "Node *current = first;\nint sum = 0;\nwhile (current) {\n    sum += current->datum;\n    current = current->next;\n}\nreturn sum;"
      ]
    },
    {
      "group": 1,
      "parsed": true,
      "num": 38,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "int sum = 0;\nfor(Node *node_ptr = first; node_ptr; node_ptr = node_ptr->next){\n    sum += node_ptr->datum;\n}\nreturn(sum);",
        "int s = 0;\nfor (Node *n = first; n != 0; n = n->next) {\n    s += n->datum;\n}\nreturn s;",
        "int sum = 0;\nfor(Node * node = first; node; node = node->next){\n    sum += node->datum;\n}\nreturn sum;",
        "int sum = 0;\nfor (Node * n = first; n; n = n->next)\n{\n    sum += n->datum;\n}\nreturn sum;",
        "int sum = 0;\nfor(Node* ptr = first; ptr; ptr = ptr->next)\n{\n    sum += ptr->datum;\n}\nreturn sum;",
        "int sum = 0;\n\nfor (Node *i = first; i; i = i->next) {\n    sum += i->datum\n}\n\nreturn sum;",
        "int sum = 0;\nfor (Node *n = first; n != 0; n = n->next) {\n  sum += n->datum;\n}\nreturn sum;",
        "int total = 0; \nfor (Node *n = first; n; n = n->next) {\n    total += n->datum;\n}\n\nreturn total;",
        "int sum = 0\nfor(Node* n = first; n; n= n->next){\n    sum+= n->datum;\n}\nreturn sum;",
        "int sum = 0;\n for(Node * begin = first; begin; begin=begin->next){\n     sum+=begin->datum;\n }\n return sum;",
        "int sum = 0;\nfor (Node *node = first; node; node = node->next) { \n    sum += node->datum;\n}\nreturn sum;",
        "int sum = 0;\nfor (Node *node = first; node; node = node->next) {\n    sum += node->datum;\n}\nreturn sum;",
        "int total = 0;\nfor(Node *ptr = first;ptr;ptr = ptr->next){\n    total += ptr->datum;\n}\nreturn total;",
        "int sum = 0;\nfor (Node *i = first; i; i=i->next) {\n    sum += i->datum;\n}\nreturn sum;",
        "int sum = 0;\nfor (Node *current = first; current; current=current->next) {\n    sum += current->datum;\n}\nreturn sum;",
        "int sum = 0;\nfor (Node* n = first; n; n = n->next) {\n    sum += n->datum;\n}\n\nreturn sum;",
        "int total = 0;\nfor(Node* cur = first; cur; cur=cur->next) {\n     total += cur->datum;\n}\n    return total;\n",
        "int s = 0;\nfor(Node *i = first; i; i = i->next) {\n    s += i->datum;\n}\n\nreturn s;",
        "int total = 0;\nfor(Node *i = first; i != 0; i = i->next){\n    total += i->datum;\n}\n\nreturn total;",
        "int sum = 0;\nfor (Node *n = first; n; n = n->next) {\n    sum += n->datum;\n}\nreturn sum;",
        "int sum = 0;\nfor(Node* node = first; node != 0; node = node->next) {\n    sum += node->datum;\n}\n\nreturn sum;",
        "int sum = 0;\nfor(Node *n = first ; n != 0 ; n=n->next){\n    sum += n->datum;\n}\nreturn sum;",
        "int m_Sum = 0;\nfor(Node* it = first; it; it = it->next)\n{\n    m_Sum += it->datum;\n}\nreturn m_Sum;",
        "        int sum = 0;\n        for (Node* ptr = first; ptr != 0; ptr = ptr->next) {\n            sum += ptr->datum;\n        }\n        return sum;",
        "int sum = 0;\nfor (Node *np = first; np; np = np->next) {\n    sum += np->datum;\n}\nreturn sum;",
        "int sum = 0;\n\nfor (Node *i = first; i != 0; i = i->next) {\n    sum += i->datum;\n}\n\nreturn sum;",
        "int total = 0;\nfor(Node *n=first; n; n = n->next){\n    total += n->datum;\n}\nreturn total;",
        "int sum = 0;\nfor (Node *node = first; node; node = node->next) {\n    sum+= node->datum;\n}\nreturn sum;",
        "int sum=0;\nfor(Node *n = first; n; n = n->next) {\n    sum+=n->datum;\n}\nreturn sum;",
        "int sum = 0;\nfor(Node *n = first; n; n = n->next){\n    sum += n->datum;\n}\nreturn sum;",
        "int sum = 0;\nfor(Node *current = first; current; current = current->next){\n    sum += current->datum;\n}\nreturn sum;\n",
        "int sum1=0;\nfor (Node *node_ptr = first; node_ptr; node_ptr = node_ptr->next) {\n    sum1+=node_ptr->datum;\n}\nreturn sum1;",
        "int sum = 0;\nfor (Node * np = first; np != 0; np = np->next){\n    sum += np->datum;\n}\nreturn sum;",
        "int sum = 0;\nfor (Node *n = first; n; n = n->next) {\n    sum += n->datum;\n}\nreturn sum;",
        "int sum = 0;\nfor (Node *np = first; np; np = np->next) {\n    sum += np->datum;\n}\nreturn sum;",
        "int sum = 0;\nfor(Node *iter = first; iter != 0; iter = iter->next) {\n    sum += iter->datum;\n}\nreturn sum;",
        "int accumulator = 0;\n\n// If the list is empty, ptr will be initalized to 0 (as first is 0)\n// and the function will simply return with 0\nfor (Node *ptr = first; ptr != 0; ptr = ptr->next) {\n  accumulator += ptr->datum;\n}\n\nreturn accumulator;",
        "int sum=0;\nfor(Node*ptr=first;ptr;ptr=ptr->next){\nsum+=ptr->datum;\n}\nreturn sum;"
      ]
    },
    {
      "group": 2,
      "parsed": true,
      "num": 19,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if (!first) {\n    return 0;\n}\nint result = 0;\nNode* current = first;\nwhile (current != 0) {\n   result += current->datum;\n   current = current->next;\n}\nreturn result;",
        "if(!first)\n{\n    return 0;\n}\nNode *n = first;\nint total = 0;\nwhile(n)\n{\n    total += n->datum;\n    n = n->next;\n}\nreturn total;",
        "if(!first){ return 0; }\nNode *ex = first;\nint sum = 0;\nwhile(ex){\nsum += ex->datum;\nex= ex->next;\n}\nreturn sum;",
        "if (!first){return 0;}\nNode *n = first;\nint sum = 0;\nwhile(n != 0){\n    sum += n->datum;\n    n = n->next;\n}\nreturn sum;",
        "if(!first) return 0;\nNode* curr = first;\nint sum=0;\nwhile(curr){\nsum+= curr->datum;\ncurr= curr->next;\n}\nreturn sum;",
        "if (!first)\n    return 0;\nint sum = 0;\nNode* tmp = first;\nwhile (tmp != 0){\n    sum += tmp->datum;\n    tmp = tmp->next;\n}\nreturn sum;",
        "if (!first) {\n    return 1;\n}\n\nNode* tracker = first;\nint sum = 0;\nwhile (tracker != 0) {\n    sum += tracker->datum;\n    tracker = tracker->next;\n}\nreturn sum;",
        "// if there is no first pointer\nif (!first)\n    return 0;\n\n// iterates over and sums it up\nint total = 0;\nNode* temp = first;\nwhile(temp) {\n    total += temp->datum;\n    temp = temp->next;\n}\n\nreturn total;",
        "if(!first) return 0;\nint total = 0;\nNode* n = first;\nwhile(n){\ntotal += n->datum;\nn = n->next;\n}\nreturn total;",
        "if(!first){\n    return 0;\n}\nNode* current=first;\nint sum=0;\nwhile(current!=0){\n    sum+=current->datum;\n    current=current->next;\n}\nreturn sum;",
        "if(!first){\n    return 0;\n}\nint sum = 0;\nNode *ptr = first;\nwhile(ptr){\n    sum += ptr->datum;\n    ptr = ptr->next;\n}\nreturn sum;",
        "if(!first) { return 0; }\n\nint sum = first->datum;\nNode * current = first;\nwhile(current){\n  sum += current->datum;\n  current = current->next;\n}\n\nreturn sum;",
        "if(!first) return 0;\nint x = 0;\nNode *n = first;\nwhile(n){\n    x += n->datum;\n    n = n->next;\n}\nreturn x;",
        "if(!first){\n    return 0;\n}\nNode *n = first;\nint sum = 0;\nwhile(n != 0){\n    sum += n->datum;\n    n = n->next;\n}\nreturn sum;",
        "if(!first) return 0;\nNode *summy = first;\nint sum = 0;\nwhile(summy)\n{\nsum += summy->datum;\nsummy = summy->next;\n}\nreturn sum;",
        "if(!first) return 0;\nNode *n = first;\nint sum = 0;\nwhile(n) {\n    sum += n->datum;\n    n = n->next;\n}\nreturn sum;",
        "if (!first) {\nreturn 0;\n}\nNode *traverse = first;\nint sum = 0;\nwhile(traverse != 0) {\n    sum += traverse->datum;\n    traverse = traverse->next;\n    }\nreturn sum;",
        "if (!first) {\n    return 0;\n}\nint sum = 0;\nNode *temp = first;\nwhile (temp != 0) {\n    sum += temp->datum;\n    temp = temp->next;\n}\nreturn sum;",
        "if (!first)\n    return 0;\nNode *current = first;\nint sum = 0;\nwhile (current) {\n    sum += current->datum;\n    current = current->next\n}\nreturn sum;"
      ]
    },
    {
      "group": 3,
      "parsed": true,
      "num": 13,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "\nif (first == 0)\n    return 0;\nNode * current = first;\nint sum = 0;\nwhile (current != 0)\n{\n    sum += current->datum;\n    current = current->next;\n}\nreturn sum;\n",
        "if(first == 0){return 0;}\nint currentSum = 0;\nNode *ptr = first;\nwhile(ptr){\n    currentSum += ptr->datum;\n    ptr = ptr->next;\n}\nreturn currentSum;",
        "if(first == 0){\n    return 0;\n}\nNode *temp = first;\nint sum = 0;\nwhile(temp != 0){\n    sum += temp->datum;\n    temp = temp->next;\n}\nreturn sum;",
        "if(first == 0) {return 0;}\nint sum = 0;\nNode *ptr = first;\nwhile(ptr!= 0){\n    sum += ptr->datum;\n    ptr = ptr->next;\n}\nreturn sum;",
        "if (first == 0){\n   return 0;\n}\nNode *n = first;\nint sum = 0;\nwhile(n != 0){\n   sum += n->datum;\n   n = n->next;\n\n}\nreturn sum;",
        "if (first == 0) {\nreturn 1;\n}\nNode *temp = first;\nint sum = 0;\nwhile(temp) {\nsum+= temp->datum;\ntemp = temp->next;\n}\nreturn sum;\n",
        "if (first == 0)\nreturn 0;\n\nNode *n = first;\nint sum =  0;\n\nwhile (n != 0){\nsum += n->datum;\nn = n->next;\n}\n\nreturn sum;",
        "if(first == 0) {\n    return 0; }\nNode *temp = first;\nint sum = 0;\nwhile(temp) {\n    sum += temp->datum;\n    temp = temp->next; }\nreturn sum;",
        "if(first == 0) {\n    return 0;\n}\nint sum = 0;\nNode * ptr = first;\nwhile(ptr != 0) {\n    sum += ptr->datum;\n    ptr = ptr->next;\n}\nreturn sum;\n",
        "if(first == 0){\n   return 0;\n}\nint x = 0;\nNode *n = first;\nwhile(n != 0){\n  x += n -> datum;\n  n = n -> next;\n}\nreturn x;",
        "if (first == 0) {return 0;}\nNode * n = first;\nint sum = 0;\nwhile (n) {\n    sum += n->datum;\n    n = n->next;\n}\nreturn sum;",
        "if (first == 0) return 0;\nNode* current_node = first;\nint sum = 0;\nwhile (current_node) {\n    sum += current_node->datum;\n    current_node = current_node->next;\n}\nreturn sum;",
        "if (first == 0) {return 0;}\nNode *n = first;\nint theSum = 0;\nwhile(n) {\n    theSum += n->datum;\n    n = n->next;\n}\nreturn theSum;"
      ]
    },
    {
      "group": 4,
      "parsed": true,
      "num": 13,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if(!first) { return 0; }\n\nint sum = 0;\n\nfor(Node * it = first; it != 0; it = it->next) {\n    sum += it->datum;\n}\n\nreturn sum;",
        "if(!first) {\n    return 0;\n}\nint sum = 0;\nfor(Node *p = first; p; p = p->next) {\n    sum += p->datum;\n}\nreturn sum;",
        "if(!first){return 0;}\nint total=0;\nfor (Node *node_ptr = first; node_ptr; node_ptr = node_ptr->next) {\n    total += node_ptr-> datum;\n}\nreturn total;",
        "if (!first)\n    return 0;\nint sum = 0;\nfor (Node *ptr = first; ptr; ptr = ptr->next){\n    sum += ptr->datum;\n}\nreturn sum;",
        "if(!first){\n    return 0;\n}\nint sum = 0;\nfor(Node *node_ptr = first; node_ptr; node_ptr = node_ptr->next){\n    sum += node_ptr->datum;\n }\n return sum; ",
        "if (!first) {\n    return 0;\n}\nint sum = 0;\nfor (Node *node_ptr = first; node_ptr; node_ptr = node_ptr->next) {\n    sum += node_ptr->datum;\n}\nreturn sum;",
        "if(!first){\n    return 0;\n}\n\nint sum = 0;\nfor(Node *n = first; n != 0; n = n->next) {\n    sum += n->datum;\n}\nreturn sum;",
        "if(!first) return 0;\nint sum = 0;\nfor(Node *n = first; n; n = n -> next){\n    sum += n->datum;\n}\nreturn sum;\n    ",
        "if (!first) {\n  return 1;\n}\n\nint sum = 0;\nfor (Node *current = first; current; current = current->next) {\n    sum += current->datum;\n  }\n\nreturn sum;",
        "      //empty\n      if(!first){return 0;}\n\n      int sum = 0;\n      for(Node *p = first; p; p = p->next){\n          sum += p->datum;\n      }\n      return sum;",
        "if(!first){\n    return 0;\n}\nint sum = 0;\nfor(Node *n = first; n; n = n->next){\n    sum+= n->datum;\n}\nreturn sum;",
        "if (!first) { // check if 0\n    return 0; // return 0 if list is empty\n}\n\nint sum_total = 0;\nfor (Node* curr = first; curr != 0; curr = curr->next) {\n    sum_total += curr->datum;\n}\n\nreturn sum_total;",
        "if(!first){\n    return 0;\n}\n\nint sum = 0;\nfor(Node* n = first; n; n = n->next){\n    sum += n->datum;\n}\nreturn sum;"
      ]
    },
    {
      "group": 5,
      "parsed": true,
      "num": 11,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if (first == 0) {\n    return 0;\n}\nint sum_result = 0;\nfor (Node *node_ptr = first; node_ptr; node_ptr = node_ptr->next) {\n    sum_result += node_ptr->datum;\n}\nreturn sum_result;",
        "if(first == 0) return 0;\nint sum = 0;\nfor (Node *node_ptr = first; node_ptr; node_ptr = node_ptr->next){\n    sum  += node_ptr->datum;\n}\nreturn sum;",
        "if (first == 0) { return 1; }\n\nint sumCount = 0;\n\nfor (Node * it = first; it != 0; it = it->next) {\n    sumCount += it->datum;\n}\n\nreturn sumCount;",
        "if(first == 0){\nreturn 0;\n}\nint sum = 0;\nfor(Node* node_ptr = first; node_ptr != 0; node_ptr = node_ptr->next){\n sum += node_ptr->datum;\n}\nreturn sum;",
        "if(first == 0) return 0;\n\n\nint sum = 0;\nfor(Node *node = first;node;node=node->next){\nsum += node->datum;\n}\nreturn sum;\n",
        "if(first == 0){\nreturn 0;}\n\nint sum = 0;\nfor(Node* ptr = first; ptr; ptr = ptr->next){\nsum += ptr->datum;\n}\nreturn sum;",
        "if (first == 0) {\n    return 0;\n}\nint sum = 0;\nfor (Node *node_ptr = first; node_ptr; node_ptr = node_ptr->next) {\n    sum += node_ptr->datum;\n}\nreturn sum;",
        "if (first == 0) { return 0;}\nint sum = 0;\nfor(Node *temp = first; temp != 0; temp = temp->next){\n    sum += temp->datum;\n}\nreturn sum;",
        "if(first==0){\n    return 0;\n}\nint result=0;\nfor(Node* ptr=first;ptr!=0;ptr=ptr->next){\n    result+=ptr->datum;\n}\nreturn result;",
        "if(first == 0) return 0\nint ans = 0;\nfor(Node *n = first; n; n= n->next){\n    ans+=n->datum;\n}\nreturn ans;",
        "if(first == 0){\n    return 0;\n}\nint sum = 0;\nfor(Node *n = first; n; n = n->next){\n        sum += n->datum;\n}\n\nreturn sum; "
      ]
    },
    {
      "group": 6,
      "parsed": true,
      "num": 8,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "int sum = 0;\nfor (Node *node_ptr = first; node_ptr; node_ptr = node_ptr->next) {\n    sum = sum + node_ptr->datum;\n}\nreturn sum;",
        "int sum = 0;\nfor(Node *n = first; n != 0; n = n->next){\n    sum = sum + n->datum;\n}\nreturn sum;",
        "int a = 0;\nfor(Node *n = first; n; n = n->next)\n{\na= n->datum+a;\n}\nreturn a;",
        "int sum = 0;\nfor(Node *node_ptr = first; node_ptr; node_ptr = node_ptr->next){\n    sum = sum + first->datum;\n}\nreturn sum;",
        "int running_sum = 0;\nfor (Node *i = first; i != 0; i=i->next) {\n    running_sum = running_sum + i->datum;\n}\nreturn running_sum;",
        "int sum = 0;\nfor(Node *ptr = first; ptr; ptr = ptr->next){\n    sum = sum + ptr->datum;\n}\nreturn sum;",
        "int sum = 0;\nfor (Node *node = first; node != 0; node = node -> next){\n    sum = sum + node -> datum;\n    }\nreturn sum;\n    ",
        "int sum = 0;\n\nfor (Node *np = first; np; np = np->next) {\n    sum = sum+np->datum;\n}\n\nreturn sum;\n"
      ]
    },
    {
      "group": 7,
      "parsed": true,
      "num": 5,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "int runningSum = 0;\nif(first == 0) { return 0; }\nfor(Node *curr = first; curr; curr=curr->next) {\n    runningSum += curr->datum;\n}\nreturn runningSum;",
        "int total = 0;\nif (first == 0) {\n    return 0;\n}\nfor (Node* s = first; s != 0; s = s->next) {\n    total += s->datum;\n}\nreturn total;",
        "int sum = 0;\nif (first == 0) {\n    return sum;\n}\nfor (Node *n_ptr = first; n_ptr; n_ptr = n_ptr->next) {\n    sum += n_ptr->datum;\n}\nreturn sum;",
        "int sum = 0;\nif (first == 0) {\n    return sum; \n}\nfor( Node *n = first; n; n= n->next) {\n    sum+= n->datum;\n }\n    return sum;",
        "int sum = 0;\nif(first == 0){\n    return sum;\n}\nfor (Node *node_ptr = first; node_ptr; node_ptr = node_ptr->next) {\n    sum += node_ptr->datum;\n}\n\nreturn sum;\n"
      ]
    },
    {
      "group": 8,
      "parsed": true,
      "num": 5,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "int result = 0;\nfor(Node *p = first; p ; p = p->next)\n  result += p->datum;\nreturn result;",
        "int sum = 0; //will be zero if first is null (empty list)\nfor(Node *ptr = first; ptr != 0; ptr = ptr->next)\n    sum += ptr->datum;\nreturn sum;",
        "int sum = 0;\nfor (Node* n = first; n; n = n->next)\n    sum += n->datum;   \n\nreturn sum;",
        "int result = 0;\nfor(Node* current = first; current; current = current->next)\n    result += current->datum;\nreturn result;",
        "int sum = 0;\nfor(Node * loc = first; loc; loc=loc->next)\n    sum += loc->datum;\nreturn sum;"
      ]
    },
    {
      "group": 9,
      "parsed": true,
      "num": 4,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if(first==0 || last==0){\n    return 0;\n}\nint sum=0;\nNode* n=first;\nwhile(n){\n    sum+=n->datum;\n    n=n->next;\n}\nreturn sum;",
        "if (first == 0 && last == 0){\n    return 0;\n    }\nNode *n = first;\nint sum = 0;\nwhile (n != 0){\n    sum += n->datum;\n    n = n->next;\n}\nreturn sum;\n    \n    ",
        "if (first == 0 && last == 0){\n    return 0;\n}\nint sum = 0;\nNode *temp = first;\nwhile (temp != 0){\n    sum += temp->datum;\n    temp = temp->next;\n}\nreturn sum;",
        "if(first == 0 && last == 0) return 0;\n\nint sum = 0;\nNode* current = first;\nwhile(current != 0)\n{\n    sum += current->datum;\n    current = current->next;\n}\nreturn sum;"
      ]
    },
    {
      "group": 10,
      "parsed": true,
      "num": 4,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "int sum = 0;\nif(!first) {\n    return sum;\n}\nfor(Node *p = first; p; p = p->next) {\n    sum += p->datum;\n}\nreturn sum;",
        "int sum = 0;\nif(!first){\n    return 0;\n}\nfor(Node *n = first; n; n = n->next){\n    sum += n->datum;\n}\nreturn sum;",
        "int total = 0;\nif (!first) {\n    return 0;\n}\nfor (Node *n = first; n != 0; n = n->next) {\n    total += n->datum;\n}\nreturn total;",
        "int sum = 0;\nif (!first) return 0;\nfor (Node *ptr= first; ptr!=0; ptr=ptr->next){\n    sum += ptr->datum;\n}\nreturn sum;"
      ]
    },
    {
      "group": 11,
      "parsed": true,
      "num": 4,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "int sum = 0;\nNode* newNode = first;\nwhile (newNode != 0) {\n    sum += newNode->datum;\n    newNode = newNode->next;\n",
        "int sum = 0;\nNode *i = first;\nwhile(i){\n    sum += i->datum;\n    i = i->next;\n}\n",
        "int sum = 0;\nNode* n = first;\nwhile (n) {\n    sum += n->datum;\n    n = n->next;\n",
        "int sum=0;\nNode *temp=first;\nwhile (temp!=0){\n    sum+=temp->datum;\n    temp=temp->next;\n"
      ]
    },
    {
      "group": 12,
      "parsed": true,
      "num": 3,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "if (first == 0)\n    return 0;\nNode *curr = first;\nint out = curr->datum;\nwhile (curr != last)\n{\n    out += curr->datum;\n    curr = curr->next;\n}\nreturn out;",
        "if (first == 0){return 0;}\nint result = 0;\nNode *node = first;\nwhile(node != last){\nresult += node -> datum;\nnode = node -> next;\n}\nreturn result;",
        "if(first==0){\n    return 0;\n}\nint sum=0;\nNode *n=first;\nwhile(n!=last){\n    sum+=n->datum;\n    n=n->next;\n}\nreturn sum;\n"
      ]
    },
    {
      "group": 13,
      "parsed": true,
      "num": 3,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if (first == 0) {\n    return 0;\n}\nint sum = 0;\nNode *ptr = first;\nwhile(ptr != 0) {\n    sum = sum + ptr->datum;\n    ptr = ptr->next;\n}\nreturn sum;\n",
        "if(first == 0){\nreturn 0;\n}\n\nNode* runner = first;\nint sum = 0;\n\nwhile(runner != 0){\nsum = sum + runner->datum;\nrunner = runner->next;\n}\n\nreturn sum;",
        "if (first == 0) { return 0; }\nNode *it = first;\nint total = 0;\nwhile (it != 0) {\n    total = total + it->datum;\n    it = it->next;\n}\nreturn total;"
      ]
    },
    {
      "group": 14,
      "parsed": true,
      "num": 3,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if(first == 0) { return 0; } // empty\nint sum = 0;\nNode * traverse = first;\nwhile(traverse != last) { //sums everything between first(incl) and last(exclusive)\n    sum += traverse->datum;\n    traverse = traverse->next;\n}\nsum += last->datum; //adds last\nreturn sum;\n",
        "if (first == 0) {\n    return 0;\n}\n\nint sum = 0;\n\nNode *temp = first;\nwhile (temp != last) {\n    sum += temp->datum;\n    temp = temp->next\n}\n\nsum += last->datum;\n\nreturn sum;\n",
        "if (first == 0){ return 0;}\nNode *n = first;\nint sum = 0;\nwhile(n != last){\n    sum += n->datum;\n    n = n->next;\n}\nsum += last->datum;\nreturn sum;   "
      ]
    },
    {
      "group": 15,
      "parsed": true,
      "num": 2,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "int sum = 0;\nNode *n = first;\nwhile (!n) {\n    sum += n->datum;\n    n = n->next;\n}\nreturn sum;",
        "int sum = 0;\nNode * ptr = first;\nwhile(!ptr) {\nsum += ptr->datum;\nptr = ptr->next;\n}\nreturn sum;"
      ]
    },
    {
      "group": 16,
      "parsed": true,
      "num": 2,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "int sum = 0;\nif(!first && !last){\n    return sum;\n}\nfor(Node *ptr = first; ptr; ptr = ptr->next) {\n    sum += ptr->datum;\n}\nreturn sum;\n",
        "int sum = 0;\nif (!first && !last){\n    return sum; \n}\nfor (Node *ptr = first; ptr; ptr = ptr->next){\n    sum += ptr->datum; \n}\nreturn sum; "
      ]
    },
    {
      "group": 17,
      "parsed": true,
      "num": 2,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "if (first == last) {\n    return 0;\n}\nint sum = 0;\nNode *n = first;\nwhile (n != last) {\n   sum += n->datum;\n   n = n->next; \n}\nreturn sum;",
        "if(first == last){\nreturn 0;\n}\nint sum = 0;\nNode* ptr = first;\nwhile(ptr != last){\nsum += ptr->datum;\nptr = ptr->next;\n}\nreturn sum;\n"
      ]
    },
    {
      "group": 18,
      "parsed": true,
      "num": 2,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "int sum = 0;\nif(first == 0) {\n    return sum;\n    }\nelse {\n    Node *newone = first;\n    while(newone != 0) {\n        sum += newone->datum;\n        newone = newone->next;\n    }\n    return sum;\n",
        "      int sum = 0;\n      if(first == 0){\n          return 1;\n      }\n      else{\n        Node * iter = first;\n        while(iter != 0){\n            sum += iter->datum;\n            iter = iter->next;\n        }\n        return sum;\n      "
      ]
    },
    {
      "group": 19,
      "parsed": true,
      "num": 2,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "int sum = 0;\nNode *head = first;\nwhile (head != last)\n{\n    head = head->next;\n    sum += head->datum;\n}\nreturn sum;",
        "int result = 0;\nNode *curr = first;\nwhile (curr != last) {\n    result += curr->datum;\n    curr = curr->next;\n}\nreturn sum;"
      ]
    },
    {
      "group": 20,
      "parsed": true,
      "num": 2,
      "submissions": [
        "if (!node)\n{return 0;}\n\nreturn node->datum + sum(node->next);",
        "if(!node){\nreturn\n}\nreturn node->data + sum(node->next);"
      ]
    },
    {
      "group": 21,
      "parsed": true,
      "num": 2,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "int s = 0;\nfor(Node* ptr = first; ptr; ptr->next){\n    s = s + ptr->datum;\n}\nreturn s;",
        "int sum = 0;\nfor(Node * n = first; n != 0; n -> next) {\n    sum = sum + n -> datum;\n}\nreturn sum;"
      ]
    },
    {
      "group": 22,
      "parsed": true,
      "num": 2,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "if (!first){\nreturn 0;}\nint sum = 0;\nfor (Node *n = first; n!=last; n = n->next){\n    sum+=n->datum;\n}\nreturn sum;",
        "if (!first) {\n    return 0;\n}\nint sum = 0;\nfor (Node * cur = first; cur != last; cur = cur->next) {\n    sum += cur->datum;\n}\nreturn sum;"
      ]
    },
    {
      "group": 23,
      "parsed": true,
      "num": 2,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "int sum = 0;\nNode *n = first;\nif(n==0){\n    return 0;\n}\nwhile(n){\nsum+=n->datum;\nn = n->next;\n}\nreturn sum;",
        "Node *n = first;\nint sum = 0;\nif (first == 0) { return 0; }\nwhile (n !=0) {\n    sum += n->datum;\n    n = n->next;\n}\nreturn sum;"
      ]
    },
    {
      "group": 24,
      "parsed": true,
      "num": 2,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "Node *n = first; \nint sum = 0;\nif(!n){\nreturn sum;\n}\nwhile(n){\n sum += n->datum;\n n = n->next;  \n}\n\nreturn sum; ",
        "Node* temp = first;\nint sum = 0;\n\nif(!temp){\n    return 0;\n}\n\nwhile(temp){\n    sum += temp->datum;\n    temp = temp->next;\n}\nreturn sum;"
      ]
    },
    {
      "group": 25,
      "parsed": true,
      "num": 2,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "//set sum to the last datum because the while loop\n//won't reach to the last node\nint sum = last->datum;\nNode *temp = first;\n\nwhile (temp != last) {\n    sum += temp->datum;\n    ++temp;\n}\n\nreturn sum;",
        "Node *it = first;\nint sum = first->datum;\nwhile(it != last){\n    ++it;\n    sum += it->datum;\n}\nreturn sum;"
      ]
    },
    {
      "group": 26,
      "parsed": true,
      "num": 2,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "int sum = 0;\nif(first == 0){\n    return 0;\n}\nelse{\n    for(Node* nodey = first; nodey; nodey = nodey->next){\n        sum += nodey->datum;\n    }    \n    return sum;\n",
        "int sum = 0;\nif (first == 0) { return sum;}\nelse {\n    for (Node *temp = first; temp; temp = temp->next) {\n        sum += temp->datum;\n    }\n    return sum;\n"
      ]
    },
    {
      "group": 27,
      "parsed": true,
      "num": 2,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if(!first || !last) {\n    return 0;\n}\nint sum = 0;\nNode *n = first;\nwhile(n != 0) {\n    sum += n->datum;\n    n = n->next;\n}\nreturn sum;",
        "if (!first && !last) {\n    return 0;\n}\n\nNode *p = first;\nint sum = 0;\nwhile (p) {\n    sum += p->datum;\n    p = p->next;\n}\n\nreturn sum;"
      ]
    },
    {
      "group": 28,
      "parsed": true,
      "num": 2,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if(!first) return 0;\nint sum = 0;\nfor(Node *n = first; n; n = n->next){\n    sum = sum + n->datum;\n}\nreturn sum;",
        "if (!first) {\n    return 0;\n}\nint sum = 0;\nfor (Node *np = first; np; np = np->next) {\n    sum = sum + np->datum;\n}\nreturn sum;"
      ]
    },
    {
      "group": 29,
      "parsed": true,
      "num": 2,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "// int total = someList.sum();\nint sum = 0;\n for (Node *node_ptr = first; node_ptr != 0;\n       node_ptr = node_ptr->next) {\n    sum += node_ptr->datum;\n  ",
        "int s=0;\nfor (Node *node_ptr = first; node_ptr != 0;\n    node_ptr = node_ptr->next) {\n    s+=node_ptr->datum;\n"
      ]
    },
    {
      "group": 30,
      "parsed": true,
      "num": 2,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if (!first) {\n    return 0;\n    }\nNode *node = first;\nint sum = 0;\nwhile (node) {\n    sum = sum + node->datum;\n    node = node->next;\n}\nreturn sum;",
        "if (!first){\n    return 0;\n}\n\nNode *victim = first;\nint total = 0;\n\nwhile (victim != 0){\n    total = victim->datum + total;\n    victim = victim->next;\n    }\n    \nreturn total; \n    "
      ]
    },
    {
      "group": 31,
      "parsed": true,
      "num": 2,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "if(first == 0){\nreturn 0;\n}\nNode *n = first;\nint sum = 0;\nwhile(n != 0){\nsum += n->datum;\nn = n->next;\n}\n",
        "if(first == 0){\n    return 0;\n}\nNode* tracker = first;\nint sum = 0;\nwhile(tracker != 0){\n    sum += tracker->datum;\n    tracker = tracker->next;\n"
      ]
    },
    {
      "group": 32,
      "parsed": true,
      "num": 2,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if(first == 0) {return 0;}\n\nif(first == last) {return first->datum;}\n\nNode* cur = first;\nint sum = 0;\nwhile(cur != 0) { \n    sum += cur->datum;\n    cur = cur->next;\n}\n\nreturn sum;\n",
        "if(first == 0) return 0;\nif(first == last) return first->datum;\nNode* ptr = first;\nint sum = 0;\nwhile(ptr){\n    sum+= ptr->datum;\n    ptr = ptr->next;\n    }\nreturn sum;\n    "
      ]
    },
    {
      "group": 33,
      "parsed": true,
      "num": 2,
      "submissions": [
        "int sum = 0;\nfor (Node *node_ptr = first; node_ptr != 0; node_ptr = node_ptr->next) {\n    sum = sum +node->datum;\n}\nreturn sum;",
        "int sum = 0;\nfor (Node *np = first; np != 0; np = np->next) {\n    sum = sum + node->datum;\n    }\nreturn sum;"
      ]
    },
    {
      "group": 34,
      "parsed": true,
      "num": 2,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if(first == 0)\n    return 0;\nint sum = 0;\nfor(Node *np = first; np; np = np->next)\n    sum += np->datum;\nreturn sum;",
        "if(first == 0) return 0;\n\nint sum = 0;\nfor(Node *ptr = first; ptr != 0; ptr = ptr->next)\n    sum += ptr->datum;\nreturn sum;"
      ]
    },
    {
      "group": 35,
      "parsed": true,
      "num": 2,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "if(!first){\n    return 0;\n}\nNode *add_up = first;\nint result;\nwhile(add_up){\n    result = result + (add_up->datum);\n    add_up = add_up->next;\n}\nreturn result;\n    ",
        "if(!first){\n    return 0;\n}\nNode *add_up = first;\nint result;\nwhile(add_up){\n    result = result + (add_up->datum);\n    add_up = add_up->next;\n}\nreturn result;\n    "
      ]
    },
    {
      "group": 36,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "int count = 0;\nif (!first) {\n    return 0;\n}\n\nfor(Node *n = first; n; n = n->next) {\n    count++;\n}\n\nreturn count;\n"
      ]
    },
    {
      "group": 37,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if(first == 0) return 0;\n// If only one node\nif(first == last) return first->datum;\n// If there's more than one node\nNode *currentN = first;\nint total = 0;\nwhile(currentN != last){\n    total = total + currentN->datum;\n    currentN = currentN->next;\n}\ntotal = total + last->datum;\nreturn total;"
      ]
    },
    {
      "group": 38,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "int total = 0;\nif(first == 0) {\n    return 0;\n}\nelse {\n    for (Node *n = first; n <= last; n->next) {\n        total = total + n->next->datum;\n    }\n    return total;\n"
      ]
    },
    {
      "group": 39,
      "parsed": true,
      "num": 1,
      "submissions": [
        "if (!first) return 0;\nif (first == last) return node->datum;\n\nNode * p = first;\nint total = 0;\nwhile (p){\n    total = total + p->datum;\n    p = p->next;\n"
      ]
    },
    {
      "group": 40,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "    int sum = 0;    \n    if (!first) {\n        return 0;\n    }\n    else {\n        for (Node *n = first; n; ++n) {\n            sum += n->datum;\n        }\n    "
      ]
    },
    {
      "group": 41,
      "parsed": true,
      "num": 1,
      "submissions": [
        "if (first == 0) {return 0;}\nNode *n = first;\nwhile (n != 0) {\n    sum += n->datum;\n    n = n->next;\n}\nreturn sum;\n"
      ]
    },
    {
      "group": 42,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if (!first){return 0;}\nif (first==last){return first->datum;}\nint sum=0;\nfor (Node *node=first;node;++node){\n    sum+=node->datum;\n}\nreturn sum;"
      ]
    },
    {
      "group": 43,
      "parsed": true,
      "num": 1,
      "submissions": [
        "int sum = 0;\nfor(Node* it = first; it != 0; it->next){\nsum = sum+ *it;\n}\nreturn sum;"
      ]
    },
    {
      "group": 44,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if(first == last) {\n    return 0;\n}\n\nint sum = 0;\nNode *n = first;\n\nwhile (n != 0) {\n    sum += n->datum;\n    n = n->next;\n}\n\nreturn sum;"
      ]
    },
    {
      "group": 45,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "int sum = 0; \nif(first == 0){\n  return 0; \n}\nif(first->next == 0){\n  return first->datum; \n}\nwhile(first->next != last){\n    sum += first->datum; \n    first = first->next; \n}\nsum += last->datum; \nreturn sum; "
      ]
    },
    {
      "group": 46,
      "parsed": true,
      "num": 1,
      "submissions": [
        "int sum = 0;\nif(!node) return 0;\nfor(Node *n = first; n; n = n->next) {\n    sum += n->datum;\n}\nreturn sum;"
      ]
    },
    {
      "group": 47,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "if (!first) return 0; // list is empty\nNode* iter = first;\nint count = 1; // start at one, counting 'first'\nwhile (iter != last) {\n    ++count;\n    iter = iter->next;\n}\nif (last) ++count; // add one for 'last', so long as it is not 0\nreturn count;"
      ]
    },
    {
      "group": 48,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if(first == 0 && last == 0) {\n    return 0;\n}\nNode *current = first;\nint sum = 0;\nwhile (current != last) {\n  sum += current -> datum;\n  current = current -> next;\n}\nsum += current -> datum;\n\nreturn(sum);"
      ]
    },
    {
      "group": 49,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "int sum = 0;\nNode *i = first;\nwhile(i != last -> next) {\n    sum += i -> datum;\n    i = i -> next;\n}\nreturn sum;"
      ]
    },
    {
      "group": 50,
      "parsed": true,
      "num": 1,
      "submissions": [
        "int total = 0;\nfor(int *i = first; i != 0; i->next)\n{\ntotal = total + datum;\n}\nreturn total;"
      ]
    },
    {
      "group": 51,
      "parsed": true,
      "num": 1,
      "submissions": [
        "int sum = 0;\nfor(Node *ptr = list.first; ptr; ptr++){\n    sum = sum + ptr->datum;\n}\nreturn sum;"
      ]
    },
    {
      "group": 52,
      "parsed": false,
      "num": 1,
      "submissions": [
        "if(first == 0){ return 0 }\nint sum = 0;\nstruct Node * node_ptr = first;\nwhile(node_ptr){\n    sum += node_ptr->datum;\n    node_ptr = node_ptr->next;\n}\nreturn sum;"
      ]
    },
    {
      "group": 53,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "int sum = 0;\nNode * temp = first;\nwhile (temp){\n    ++sum;\n    temp = temp->next;\n}\nreturn sum;"
      ]
    },
    {
      "group": 54,
      "parsed": false,
      "num": 1,
      "submissions": [
        "if(first == last){ return 0}\nint sum = 0; \nNode *node_ptr = first;\nwhile(node_ptr){\n    sum += node_ptr-datum;\n    node_ptr = node_ptr->next;\n}\nreturn sum;"
      ]
    },
    {
      "group": 55,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "int sum = 0;\n \nfor(Node *n = first; n; n->next) {\n    sum += n->datum;\n}\n\nreturn sum;"
      ]
    },
    {
      "group": 56,
      "parsed": true,
      "num": 1,
      "submissions": [
        "if (!first){\nreturn 0; \n}\nNode *b = *first;\nint tot = first->datum;\nwhile(b->next != 0){\ntot += b->next->datum;\nb = b->next;\n}\nreturn tot;"
      ]
    },
    {
      "group": 57,
      "parsed": false,
      "num": 1,
      "submissions": [
        "int sum; = 0;\nif (empty()) { return sum; }\nelse {\n    Node *ptr = first;\n    while (ptr != 0) {\n    ptr = ptr->next;\n     sum += Node->datum;\n     }\n "
      ]
    },
    {
      "group": 58,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "Node* current = first;\nint sum = 0;\n\nfor (Node* ptr = first; ptr; ++ptr) {\n    sum += ptr->datum;\n}\n\nreturn sum;"
      ]
    },
    {
      "group": 59,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "int s=0;\nif(first==0&&last==0){\n    return 0;\n}\nfor (Node *node_ptr = first; node_ptr; node_ptr = node_ptr->next) {\n    s+=node_ptr->datum;\n}\nreturn s;"
      ]
    },
    {
      "group": 60,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if (!first) {\nreturn 0;}\nint x = 0;\nfor (Node *node = first; node; node->next) {\n    x = node->datum + x;\n}\nreturn x;"
      ]
    },
    {
      "group": 61,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "Node * n = first;\nif(n == 0) {\n    return 0;\n}\nint sum = 0;\n\nfor(n;n;n = n->next) {\n    sum += n->datum;\n}\nreturn sum;"
      ]
    },
    {
      "group": 62,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "int sum = 0;\nif(first == 0){\n    return sum;\n}\nNode* track = first;\nwhile(track != last){\n    sum += track->datum;\n    track = track->next;\n}\nreturn sum; "
      ]
    },
    {
      "group": 63,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "int sum = 0;\nif (first == 0 && last == 0) {\n    return sum;\n}\nNode *ptr = first;\nwhile (ptr != 0) {\n    sum += ptr->datum;\n    ptr = ptr->next;\n}\nreturn sum;"
      ]
    },
    {
      "group": 64,
      "parsed": false,
      "num": 1,
      "submissions": [
        "if (first == 0 && last == 0){\n    return 0;\n}\nint sum = 0;\nelse{\n    Node *ptr = first\n    for(ptr; ptr != 0; ptr = ptr->next){\n        sum += ptr->datum;\n    }\n    return sum;\n}\n"
      ]
    },
    {
      "group": 65,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if(first == 0){return 0;}\nNode *nPtr = first;\nint sumOf = 0;\nif(first == last){ return first->datum;}\nelse{\nwhile(nPtr != last){\n    sumOf += nPtr->datum;\n    ++nPtr;}\nsumOf += last->datum;}\n    return sumOf;\n"
      ]
    },
    {
      "group": 66,
      "parsed": true,
      "num": 1,
      "submissions": [
        "\tif (!first) { //list is empty\n\t\treturn 0;\n\t}\n\tif (first == last) //list is one element\n\t\treturn *first;\n\n\tint sum = 0;\n\tNode *temp = first;\n\twhile (temp->next) {\n\t\tsum += *temp;\n\t\ttemp = temp->next;\n\t}\n\treturn sum;"
      ]
    },
    {
      "group": 67,
      "parsed": false,
      "num": 1,
      "submissions": [
        "Node *it = first;\nint result = 0;\nif (it = 0) {\n    return result;\n}\nelse {\n    while (it! = 0) {\n        result += it-> datum; \n        it = it ->next;\n    }\n    return result;\n"
      ]
    },
    {
      "group": 68,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "int total = 0;\nif(first){\n    for(Node *n = first; n; n = n->next){\n        total += n->datum;\n    }\n}\nreturn total;"
      ]
    },
    {
      "group": 69,
      "parsed": true,
      "num": 1,
      "submissions": [
        "int count;\nif (first == 0){\nreturn 0;\n}\nelse{\nfor(Node * i = first; i != last; i = next){\ncount++;\n   }\n"
      ]
    },
    {
      "group": 70,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "int sum = 0;\nNode* n = first;\nif(n){\n    sum += n->datum;\n    n = n->next;\n}\nreturn sum;"
      ]
    },
    {
      "group": 71,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if(first==0){return 0;}\nint sum = 0;\nNode *temp=first;\nwhile(temp!=last){\nsum = sum + temp->datum;\ntemp=temp->next;\n}\nsum = sum+last->datum;\n\nreturn sum;"
      ]
    },
    {
      "group": 72,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "if(first==0 || last==0)\n    return 0;\n    \nint sum=0;\nfor(Node *n = first; n; n = n->next){\n    sum++;\n}\nreturn sum;"
      ]
    },
    {
      "group": 73,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "int total = 0;\nif(first == 0){\n    return total;\n}\n\nNode *n = first;\nwhile(n != 0){\n    ++total;\n    n = n -> next;\n}\nreturn total;"
      ]
    },
    {
      "group": 74,
      "parsed": true,
      "num": 1,
      "submissions": [
        "if (first = 0){\n    return 0;\n}\nelse{\n    int count = 0;\n    Node *counter = first;\n    for (; counter != last; counter=counter->next){\n        count = count + (counter->datum);\n    }\n}\nreturn count;"
      ]
    },
    {
      "group": 75,
      "parsed": true,
      "num": 1,
      "submissions": [
        "if(first == NULL) return 0;\n\nNode *temp = first;\nint sum = 0;\nwhile(temp) {\n    sum += temp->datum;\n    temp = temp->next;\n}\nreturn sum;"
      ]
    },
    {
      "group": 76,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "int sum = 0;\nNode * n = first;\nif(!first){\n    return 0;\n}\nwhile(!n){\n    sum = sum + n->datum;\n}\nreturn sum;"
      ]
    },
    {
      "group": 77,
      "parsed": true,
      "num": 1,
      "submissions": [
        "int sum = 0;\nif (first == 0) {\n    return sum;\n}\nsum = *first;\nfor (Node* node_ptr = first; node_ptr; node_ptr = node_ptr->next) {\n    sum += *next;\n    }\n    return sum;"
      ]
    },
    {
      "group": 78,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "if(first == last){\n    return 0;\n}\nNode *counter = first;\nint sum = 0;\nwhile(counter != last){\n    sum = sum + counter->datum;\n    counter = counter->next;\n}\nreturn sum;"
      ]
    },
    {
      "group": 79,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "int sum = 0;\nif (first == 0) {\nreturn 0;\n}\nfor (Node *n = first; n!=last; n->next) {\nsum+= n->datum;\n}\nreturn sum;"
      ]
    },
    {
      "group": 80,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "int sum = 0;\nif (!first && !last) {\n    return 0;\n}\n\nNode *current = first;\n\nwhile (current) {\n    sum += current->datum;\n    current = current->next;\n}\n\nreturn sum;"
      ]
    },
    {
      "group": 81,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "int sum = 0;\nNode *n = first;\n\nif(!first){\n    return 0;\n}\nfor(Node* n = first; n; n = n->next){\n    sum = sum + n->datum;\n}\nreturn sum;"
      ]
    },
    {
      "group": 82,
      "parsed": true,
      "num": 1,
      "submissions": [
        "int return_sum = 0;\nfor (Node *node_ptr = first; node_ptr; node_ptr = node_ptr->next)\n{\n    if (!node && node -> prev == 0 && node -> next == 0)\n    {\n        return 0;\n    }\n    return_sum += node->datum;   \n}\n\n"
      ]
    },
    {
      "group": 83,
      "parsed": true,
      "num": 1,
      "submissions": [
        "int sum = 0;\nNode *temp = first;\nwhile (temp != 0) {\n    if (first == 0 && last == 0) {\n    return 0;\n    }\n    else {\n    sum = temp + temp->next;\n    }\n}\nreturn sum;\n"
      ]
    },
    {
      "group": 84,
      "parsed": false,
      "num": 1,
      "submissions": [
        "int count = 0;\nNode* current = this->first;\nwhile(current != this->last){\ncount += current->datum;\ncurrent = current->next;\n}\ncount += this->last->datum // this line accounts for the final node's value\n\nreturn count;"
      ]
    },
    {
      "group": 85,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if (first == 0) {\nreturn 0;\n}\nint sum = 0;\nNode* counter = first;\nfor (; counter != 0; counter = counter -> next) {\nsum = sum + counter -> datum;\n}\nreturn sum;"
      ]
    },
    {
      "group": 86,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "if(!first){\n    return 0;\n}\nNode *count = first;\nint sum=0;\nwhile(true){\nsum+=count-> datum;\nif(count == last)\n    return sum;\nfirst = first -> next;\n}\nreturn -1;"
      ]
    },
    {
      "group": 87,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "Node *myNode = new Node(); //creating a new node\nmyNode = first; //starting with the first node\nint sum = 0; //int since the datum type is also an int\n\n//looping through our nodes\n//until we hit a 0\nwhile (myNode != 0) {\n    sum = sum + myNode->datum; //adding to sum\n    myNode = myNode->next; //going to the next node\n}\n\n//returning the sum\nreturn sum;"
      ]
    },
    {
      "group": 88,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "int sum = 0;\nif (first == 0) {\n    return 0;\n}\nif (first == last) {\n    return first->datum;\n}\nelse {\n    Node* temp = first;\n    while (temp != 0) {\n        sum = sum + temp->datum;\n        temp = temp->next;\n    }\n}\nreturn sum;"
      ]
    },
    {
      "group": 89,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "Node *temp = first;\nint sum;\n\nwhile(temp){\n    sum = sum + temp->datum;\n    temp = temp->next;\n}\n\nreturn sum;"
      ]
    },
    {
      "group": 90,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "int summ = 0;\nNode * curr = first;\n\nwhile(curr){\n    summ = summ + curr->datum;\n    curr = curr->next;\n}\n\nreturn summ;\n"
      ]
    },
    {
      "group": 91,
      "parsed": true,
      "num": 1,
      "submissions": [
        "int sum = 0;\nif(!first)\n    return 0;\nfor(Node *i = first; i != last; i = i->next){\n    sum += i->datum;\n}\nreturn datum;"
      ]
    },
    {
      "group": 92,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "       if (first == 0) {\n            return 0;\n        }\n\n        Node* n = first;\n        int sum = n->datum;\n        for (; n != last; n = n->next) {\n            sum += n->datum;\n        }\n        return sum;\n    "
      ]
    },
    {
      "group": 93,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "if(first==0){\n    return 0;\n}\nNode *temp = first;\nint sum = 0;\nwhile(temp->next){\n    sum += temp->datum;\n    temp = temp->next;\n}\nreturn sum;"
      ]
    },
    {
      "group": 94,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if (!first) {\n    return 0;\n}\nNode * current = first;\nint sum = current->datum;\nwhile (current->next != 0) {\n    current = current->next;\n    sum += current->datum;\n}\nreturn sum;"
      ]
    },
    {
      "group": 95,
      "parsed": true,
      "num": 1,
      "submissions": [
        "if (first == 0 && last == 0) {\n        return 0;\n    }\nelse {\n        int x;\n        Node *tmp;\n        tmp = first;\n        while (tmp != NULL) {\n            x = x + tmp->datum;\n            tmp = tmp->next;\n        }\n        return x;"
      ]
    },
    {
      "group": 96,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "Node * ptr = first;\nint S = 0;\nwhile ( ptr->next ) {\n    S += ptr->datum;\n    ptr = ptr->next;\n}\n\nreturn S;"
      ]
    },
    {
      "group": 97,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if (!first){\nreturn 0;\n}\nelse {\nint sum =0;\nNode * n = first;\n\nwhile(n){\nsum += n->datum;\nn = n->next;\n}\n\nreturn sum;\n"
      ]
    },
    {
      "group": 98,
      "parsed": false,
      "num": 1,
      "submissions": [
        "if(empty()){\n    return 0;\n}\nint c = 0\nfor (Iterator i = first, i !=last, ++i){\n    c += i->datum;\n}\nreturn c;"
      ]
    },
    {
      "group": 99,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "if(!first) return 0;\nint count = 1;\nfor(Node *ptr = first; ptr != last; ptr=ptr->next) {\n  count++;\n}\nreturn count;"
      ]
    },
    {
      "group": 100,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if(first == 0){\nreturn 0;\n}\nelse{\n    int runningValue = 0;\n    for (Node *node_ptr = first; node_ptr; node_ptr = node_ptr->next) {\n    runningValue+= node_ptr->datum;\n    }\n    return runningValue;\n    "
      ]
    },
    {
      "group": 101,
      "parsed": false,
      "num": 1,
      "submissions": [
        "int sum = 0;\nif(!first){ return 0;} // empty list \nNode* current = first;\nelse{\n    while( current != last){ //end at last\n        ++sum;\n        current = current->next; // move to next pointer\n    }\n    sum = sum + 1; // add one for last \n}\nreturn sum;\n    \n"
      ]
    },
    {
      "group": 102,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "int sum = 0;\nif(!first) {\n    return sum;\n}\nfor(Node *it = first; it->next; it = it->next) {\n    sum += it->datum;\n}\nreturn sum;"
      ]
    },
    {
      "group": 103,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "Node *n = new Node;\nint sum = 0;\nn = first;\nif(!first){\n    return 0;\n}\nelse{\n    while(n){\n        sum += n->datum;\n        n = n->next;\n    }\n}\nreturn sum;"
      ]
    },
    {
      "group": 104,
      "parsed": false,
      "num": 1,
      "submissions": [
        "int sum = 0;\nif(first == 0 && last== 0)\n    return 0;\nfor(Node *node_ptr = first; node_ptr != 0; node_ptr = node_ptr->next;\n{\n    sum += node_ptr->datum;\n}\nreturn sum;"
      ]
    },
    {
      "group": 105,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if (!first) {\n    return 0;\n}\nNode *hold = first;\nint sum = 0;\nwhile( hold != last) {\nsum += hold->datum;\nhold = hold->next;\n}\nsum += hold->datum;\nreturn sum;"
      ]
    },
    {
      "group": 106,
      "parsed": true,
      "num": 1,
      "submissions": [
        "    int sum = 0;\n    Node* ptr = first;\n    Node* ptr_next;\n\n    while (ptr != NULL) {\n      ptr_next = ptr->next;\n\n      sum += ptr->datum;\n      ptr = ptr_next;\n    }\n\n    return sum;"
      ]
    },
    {
      "group": 107,
      "parsed": false,
      "num": 1,
      "submissions": [
        "    auto it = first; \n    int s=0;\n    while(it!=last){\n      s+=it->datum;\n      it=it->next;\n    }\n    return s;"
      ]
    },
    {
      "group": 108,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "Node *ptr = first;\nint total = 0;\nif (ptr == 0) {\nreturn 0;\n}\nelse {\nfor(;ptr != 0; ptr = ptr->next) {\ntotal += ptr->datum;\n}\nreturn total;\n"
      ]
    },
    {
      "group": 109,
      "parsed": false,
      "num": 1,
      "submissions": [
        "if (!first) {\n    return 1;\n}\nint sum = 0;\nfor (auto i = first; i; i = i->next) {\n    sum += *i;\n}\nreturn sum;"
      ]
    },
    {
      "group": 110,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "if (first == 0){return 0;}\nint sum=0;\nfor(Node *node_ptr = first;node_ptr!=last; node_ptr = node_ptr->next){\n    sum += node_ptr->datum;\n}\nreturn sum;"
      ]
    },
    {
      "group": 111,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if(first == last) {return 0;}\n\nint result = 0;\nNode *temp = first;\nfor(;temp != 0; temp = temp->next){\n    result += temp -> datum;\n}\nreturn result;"
      ]
    },
    {
      "group": 112,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "int sum = 0;\nif (!first && !last) { return sum; }\nfor (Node* np = first; !np; np = np->next) {\n    sum += np->datum;\n}\nreturn sum;"
      ]
    },
    {
      "group": 113,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        ""
      ]
    },
    {
      "group": 114,
      "parsed": true,
      "num": 1,
      "submissions": [
        "int sum = 0;\nfor (Node * it = first; it != 0; it = it->next) {\n    sum += *i; \n}\nreturn sum; "
      ]
    },
    {
      "group": 115,
      "parsed": true,
      "num": 1,
      "submissions": [
        "if (!first) {\n    return 0;\n}\nsum = 0;\nNode *n = first;\nwhile (n) {\n    sum += n->datum;\n    n = n->next;\n}\n\nreturn sum;"
      ]
    },
    {
      "group": 116,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "int totalSum = 0;\nif (!first) {\nreturn 0;}\nelse if (first == last) {\nreturn first->datum;}\nelse {\nwhile (first != last) {\ntotalSum = totalSum + first->datum;\nfirst = first->next;\n}\nreturn totalSum;"
      ]
    },
    {
      "group": 117,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "int sum = 0;\nif (first == 0) {\n    return 0;\n}\nelse {\n    for (Node*i=first; i != 0; i = i->next) {\n        sum = (sum + i->datum);\n    }\n}\nreturn sum;"
      ]
    },
    {
      "group": 118,
      "parsed": true,
      "num": 1,
      "submissions": [
        "if(first == nulltpr){\n    return 0;\n    }\nelse{\n    sum = first->datum;\n    Node *current = first;\n    while(current->next){\n        current = current->next;\n        sum = sum + current->datum;\n    }\n    return sum;"
      ]
    },
    {
      "group": 119,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "// EFFECTS: Returns the product of all the Nodes in the linked list.\n  // Returns 1 if the list is empty.\nif(!first){ return 1; }\n\nint product;\nfor(Node *it = first; it != last; it++){\n    if(it->datum){\n        product *= it->datum;\n    }\n}\nreturn product;"
      ]
    },
    {
      "group": 120,
      "parsed": false,
      "num": 1,
      "submissions": [
        "List list1;\nif(){\n    return 0;\n}\nint sum = 0;\nfor(auto it = list1.begin(); it != list1.end();++it){\n sum += *it;\n}\n\nreturn sum;"
      ]
    },
    {
      "group": 121,
      "parsed": true,
      "num": 1,
      "submissions": [
        "if (first == 0) return 0;\nNode * current_node = first;\nint sum_placeholder = 0;\nwhile(current_node != 0) {\n    sum = sum + current_node->datum;\n    current_node = current_node->next;\n"
      ]
    },
    {
      "group": 122,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "Node* ptr = this->first;\nint sum = 0;\n\nwhile(ptr != this->last){\n    sum += ptr->datum;\n    ptr = ptr->next;\n}\n\nreturn sum;"
      ]
    },
    {
      "group": 123,
      "parsed": false,
      "num": 1,
      "submissions": [
        "int sum = 0;\nif (first == 0 && last == 0) {\n    return 0;\n}\nelse {\n    for (Node *np = first; np; np = np -> next) {\n        sum = sum + np -> datum;\n    }\n    returun sum;\n"
      ]
    },
    {
      "group": 124,
      "parsed": false,
      "num": 1,
      "submissions": [
        "int sum=0;\nif(!first)\n    return 0;\nfor(node * it=first; it !=last;it= it->next){\n    sum += it->datum;\n}\nreturn sum;"
      ]
    },
    {
      "group": 125,
      "parsed": true,
      "num": 1,
      "submissions": [
        "if (!first) {\n    return 0;\n}\nelse {\n    Node *current = first;\n    int sum = 0;\n\n    while (current->next) {\n        sum += current->datum;\n        current = current->next;\n    }\n} \n\nreturn sum;"
      ]
    },
    {
      "group": 126,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if (first==last) return 0;\nint sum = 0;\nwhile (first != last){\n    sum = sum + first->datum;\n    first = first->next;\n}\nsum = sum+last->datum;\nreturn sum;"
      ]
    },
    {
      "group": 127,
      "parsed": true,
      "num": 1,
      "submissions": [
        "int sum = 0;\nnode->start = first;\nwhile (start != 0) \n{\n    sum+= first->datum;\n    start = start->next;\n}\nreturn start;    "
      ]
    },
    {
      "group": 128,
      "parsed": true,
      "num": 1,
      "submissions": [
        "int cur_sum = 0;\nNode *n = first;\nwhile (n) {\n    sum += n->datum;\n    n = n->next;\n}\nreturn cur_sum;"
      ]
    },
    {
      "group": 129,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if (first == 0 && last == 0) { return 0; }\nint sum = 0;\nfor (Node * it = first; it; it->next) {\n   sum += it->datum;\n}\nreturn sum;\n"
      ]
    },
    {
      "group": 130,
      "parsed": true,
      "num": 1,
      "submissions": [
        "if (first == 0 && last == 0) {\n    return 0;\n    } \nint sum = 0; \nNode *ptr = first; \nwhile (ptr != 0) {\n    sum = sum + *ptr; \n    ptr->next;\n    }\nreturn sum; "
      ]
    },
    {
      "group": 131,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "int total = 0;\nif(first == 0){\n    return total;\n}\nNode* tracker = first;\nwhile(tracker != 0){\n    total += tracker->datum;\n    tracker = tracker->next;\n}\nreturn total;"
      ]
    },
    {
      "group": 132,
      "parsed": true,
      "num": 1,
      "submissions": [
        "if (first == 0){\nreturn 0;\n}\nsum = 0;\nfor (Node *i  = begin; i; i->next){\nsum = sum + i->datum;\n}\nreturn sum;\n"
      ]
    },
    {
      "group": 133,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "if(first == 0 && last == 0)\n{\n  return 0;\n  }\nint val = 0;\nfor(Node *node_ptr = first; node_ptr == last; node_ptr = node_ptr->next)\n{\n  val += node_ptr->datum;\n  }\n  return val;"
      ]
    },
    {
      "group": 134,
      "parsed": false,
      "num": 1,
      "submissions": [
        "if (!first) return 0;\nint sum = 0;\nfor (node *ptr = first ; ptr != 0 ; ptr=ptr->next) {\n    sum += ptr->datum;\n}\nreturn sum;"
      ]
    },
    {
      "group": 135,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "Node* n = first;\nint sum = n->datum;\n\nwhile (n->next) {\n    sum += n->next->datum;\n}\n\nreturn sum;"
      ]
    },
    {
      "group": 136,
      "parsed": false,
      "num": 1,
      "submissions": [
        "if(empty()){return 0;}\nIterator end = end();\nint sum = 0;\nfor (Iterator it = begin(); it != end; ++it){\n    sum += *it;\n}\nreturn sum;"
      ]
    },
    {
      "group": 137,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if (!first) { return 0; }\nNode *temp = first;\nint result = 0;\nwhile (temp) {\n    result += temp->datum;\n    temp++;\n}\nreturn result;"
      ]
    },
    {
      "group": 138,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "int sum = 0;\nif(!first) return 0;\nif(first == last) return first->datum;\n\nNode * it = first;\nwhile(it != last){\n    sum += it->datum;\n    it = it->next;\n}\nreturn sum;\n\n"
      ]
    },
    {
      "group": 139,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "int count = 0;\nif(first == 0) { return count;}\nfor(Node *ca = first; ca; ca =ca->next)\n{\n    count = count + ca->datum;\n}\nreturn count;"
      ]
    },
    {
      "group": 140,
      "parsed": true,
      "num": 1,
      "submissions": [
        "Node *i = first;\nsum = 0;\nwhile(i){\n    sum += i->datum;\n    i = i->next;\n}\nreturn sum; "
      ]
    },
    {
      "group": 141,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "int nodeSum = 0;\n//initialized to 0, so if the list is empty, 0 will return\n//add each node amount to nodeSum\nreturn nodeSum;"
      ]
    },
    {
      "group": 142,
      "parsed": false,
      "num": 1,
      "submissions": [
        "if (!first) {\n    return 0;\n}\nnode *p = first;\nwhile(p != 0) {\n    sum += p->datum;\n    p = p->next;\n}\nreturn sum;"
      ]
    },
    {
      "group": 143,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "int sum = 0;\nif(!first) {return sum;}\nelse{\nNode*temp = first;\nwhile(temp){\nsum += temp->datum;\ntemp = temp->next; }\nreturn sum;\n}\n"
      ]
    },
    {
      "group": 144,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "int totalSum = 0;\nif(first == 0 || first == last){\n    return totalSum;\n}\nfor(Node * nodeptr = first; nodeptr; nodeptr->next){\n    totalSum = totalSum + nodeptr->datum;\n}\nreturn totalSum;"
      ]
    },
    {
      "group": 145,
      "parsed": true,
      "num": 1,
      "submissions": [
        "if (first == 0) {\n    return 0;\n} \nint count = 0;\nfor (Node *n = first; n; n = n->next) {\n    count += (*n)->datum;\n}\nreturn count;"
      ]
    },
    {
      "group": 146,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if (this->first == 0) {\n    return 0;\n}\nint sum = 0;\nfor (Node *node_ptr = first; node_ptr; node_ptr = node_ptr->next) {\n    sum += node_ptr->datum;\n}\nreturn sum;"
      ]
    },
    {
      "group": 147,
      "parsed": true,
      "num": 1,
      "submissions": [
        "int sum = *this->datum;\nwhile(this->next){\n    sum += *this->next->datum;\n    this = this->next;\n}\nsum += *this->datum;"
      ]
    },
    {
      "group": 148,
      "parsed": false,
      "num": 1,
      "submissions": [
        "if(!first){return 0};\nint sum = 0;\nfor(Node* ptr = first; ptr == last; ptr = first->next){ sum += ptr->datum;}\nreturn sum;\n"
      ]
    },
    {
      "group": 149,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "Node * temp = first;\nif (temp == 0){\n    return 1;\n}\nint sum = 0;\nwhile (temp->next != 0){\n    sum += temp->datum;\n    temp = temp->next;\n}\nreturn sum;"
      ]
    },
    {
      "group": 150,
      "parsed": true,
      "num": 1,
      "submissions": [
        "int sum = 0\nif (!first == last){\n    return 1;\n}\nfor (Node *n = first; n; n->next){\n    sum += n->datum;\n}\nreturn sum;"
      ]
    },
    {
      "group": 151,
      "parsed": true,
      "num": 1,
      "submissions": [
        "int sum = 0;\nif(first == 0) return 0;\nfor (Node *np = first; np != last; np = np->next){\n        sum += np->data; \n}\nreturn sum;"
      ]
    },
    {
      "group": 152,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "int sum = 0;\nfor (Node *it = first; it != last; it = it->next) {\nsum = sum + it->datum;\n}\n\nreturn sum;"
      ]
    },
    {
      "group": 153,
      "parsed": true,
      "num": 1,
      "submissions": [
        "int sum = 0;\nif (!first){\n    return sum;\n}\nNode* counter = first;\nwhile (counter->next) {\n    sum += couter->datum;\n    counter = counter->next;\n}\nreturn sum;"
      ]
    },
    {
      "group": 154,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "if(first == 0){\n    return 0;\n}\nelse if(first == last){\n    return first->datum;\n}\nelse{\n    Node* n = first;\n    int sum = 0;\n    while(n != last){\n        sum += n->datum;\n        ++n;\n    }\n    return sum;\n}\n"
      ]
    },
    {
      "group": 155,
      "parsed": true,
      "num": 1,
      "submissions": [
        "int sum = 0;\nNode * temp = first;\nif(Node == 0){\n    return sum;\n    }\nwhile(temp != 0){\n    sum += temp->datum;\n    temp = temp->next;\n}\nreturn sum;"
      ]
    },
    {
      "group": 156,
      "parsed": true,
      "num": 1,
      "submissions": [
        "Node * n = first;\nif(first==last)\n{\n    return 0;\n}\nelse\n{\n    int sum = node->datum;\n    while(node!=0)\n    {\n        sum = sum + node->next->datum;\n        node=node->next;\n    }\nreturn sum;\n}\n        \n\n\n\n"
      ]
    },
    {
      "group": 157,
      "parsed": false,
      "num": 1,
      "submissions": [
        "Node* node = first;\nif(first == 0){\nreturn 0;\n}\nwhile(place != 0){\nint total += node->datum;\nnode = node->next;\n}\nreturn total;"
      ]
    },
    {
      "group": 158,
      "parsed": true,
      "num": 1,
      "submissions": [
        "int sum = 0;\nfor(int *ptr = first; ptr; ptr = ptr->next){\n    sum += ptr->datum;\n}\nreturn sum;"
      ]
    },
    {
      "group": 159,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "Node *n = first;\nint sum = 0;\nif(!n){\n    return 0;\n}\nwhile(n != last){\n    sum += n->datum;\n    n = n->next;\n}\ndelete n;\nreturn sum;"
      ]
    },
    {
      "group": 160,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "int value = 0;\nif(first == 0){\n    return 0;\n}\nelse{\n    for(Node *n = first; n != 0; n = n->next){\n        value += n->datum;\n    }\n}\nreturn value;"
      ]
    },
    {
      "group": 161,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "   int sum = 0;\n    if (!first){\n    return 0;\n    }\n    else {\n    for (Node* currentNode = first; currentNode != 0; currentNode = currentNode->next){\n    sum += currentNode->datum;\n    }\n    }\n    return sum;"
      ]
    },
    {
      "group": 162,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if (!first) {\n    return 0;\n}\n\nif (first == last) {\n    return first->datum;\n}\n\nint sum = 0;\n\nNode *ptr = first;\nwhile (ptr != last) {\n    sum += ptr->datum;\n    ptr = ptr->next;\n}\nsum += last->datum;\n\nreturn sum;"
      ]
    },
    {
      "group": 163,
      "parsed": true,
      "num": 1,
      "submissions": [
        "if(first == 0){\n    return 0;\n}\nNode *p = first;\nint sum = 0;\nwhile(p != 0){\n    sum += p.datum;\n    p = p->next;\n}\nreturn sum;"
      ]
    },
    {
      "group": 164,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "Node *node = first;\nint sum = 0;\nwhile(!node) {\n    sum += node->datum;\n    node = node->next;\n"
      ]
    },
    {
      "group": 165,
      "parsed": true,
      "num": 1,
      "submissions": [
        "Node *ptr = first;\nint sum = 0;\n\nwhile (ptr != 0) {\n    sum += ptr;\n    ptr = next;\n}\n\nreturn sum;"
      ]
    },
    {
      "group": 166,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "if(!first) return 0;\nint num = 0;\nfor(Node* ptr = first; ptr != last; ++ptr){\n    num += ptr->datum;\n}\nreturn num;"
      ]
    },
    {
      "group": 167,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if (!first) { return 0; }\nint sum = 0;\nfor (Node *ptr = first; ptr; ++ptr) {\n    sum += ptr->datum;\n}\nreturn sum;"
      ]
    },
    {
      "group": 168,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "if (!first) {\n    return 0;\n} else {\n    int sum = 0;\n    for (Node *node_ptr = first; node_ptr != last; node_ptr = node_ptr->next) {\n        sum += node_ptr->datum;\n    }\n    return sum;\n"
      ]
    },
    {
      "group": 169,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "int sum = 0;\nif (first == 0){\n    return sum;\n}\nwhile (first != last){\n    sum += first->datum;\n    first = first->next;\n}\nreturn sum;\n    "
      ]
    },
    {
      "group": 170,
      "parsed": false,
      "num": 1,
      "submissions": [
        "int sum = 0;\nfor(auto i : first)\n{\n    sum += i->datum;\n}\n\nreturn sum;"
      ]
    },
    {
      "group": 171,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "if (first == 0) {\n    return 0;\n}\nif (first == last) {\n    return first->datum;\n}\nint sum;\nNode* sumNode = first;\nwhile (sumNode != last) {\n    sum += sumNode->datum;\n    sumNode = sumNode->next;\n    if (sumNode == last) {\n        sum += sumNode->datum;\n        return sum;\n    }\n}\nreturn sum;"
      ]
    },
    {
      "group": 172,
      "parsed": true,
      "num": 1,
      "submissions": [
        "int counter = 0;\nfor (Node *node_ptr = first; node_ptr; node_ptr = node_ptr->next) {\n            counter = counter + *node_ptr;\n        }\n        \nreturn counter;"
      ]
    },
    {
      "group": 173,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "int sum = 0; \nif(!first){\n    return 0; \n}\nelse{\n    for(Node *ptr = first; ptr != last; ptr = ptr->next){\n        sum += ptr->datum; \n    }\n    return sum;\n}\n"
      ]
    },
    {
      "group": 174,
      "parsed": false,
      "num": 1,
      "submissions": [
        "if List::sum() {\n    if (first == 0)\n        return 0;\n    Node *head = first;\n    int answer = 0;\n    while(head) {\n        answer += head->datum;\n        head = head->next;\n    }\n    return answer;\n"
      ]
    },
    {
      "group": 175,
      "parsed": true,
      "num": 1,
      "submissions": [
        "if(!node){\n    return 0;\n}\nNode* temp = first;\nsum = 0;\nwhile(temp != 0) {\n    sum+= temp->datum;\n}\nreturn sum;"
      ]
    },
    {
      "group": 176,
      "parsed": true,
      "num": 1,
      "submissions": [
        "int sum = 0;\nif (!Node) {return 0;}\nfor (Node *node_ptr = first; node_ptr; node_ptr = node_ptr->next) {\n    sum++;\n  }\nreturn sum; "
      ]
    },
    {
      "group": 177,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "if (first == 0) {\n    return 0;\n}\nint total = 0;\nNode *n = first;\nwhile(n != last) {\n    total += n->datum;\n    n = n->next;\n}\nn = n->next;\ntotal += n->datum;\nreturn total;\n"
      ]
    },
    {
      "group": 178,
      "parsed": true,
      "num": 1,
      "submissions": [
        "if(empty()){\n  return 0;\n  }\nint sum = 0; \nfor(Node *np = first; np; np = np->next)\n{ \n  sum += np->datum;\n}\nreturn sum;"
      ]
    },
    {
      "group": 179,
      "parsed": true,
      "num": 1,
      "submissions": [
        "if(node == 0) {\n    return 0;\n}\nelse {\n    int total = 0;\n    for(Node *n = first; n; n = n->next) {\n        total += n->datum;\n    }\n    return total;\n"
      ]
    },
    {
      "group": 180,
      "parsed": true,
      "num": 1,
      "submissions": [
        "int sum = 0;\nfor(Node i = first; i != 0; i->next)\n    sum += i.datum;\n\nreturn sum;"
      ]
    },
    {
      "group": 181,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if(first == 0){\n    return 0;\n}\nint sum = 0;\nfor(Node *i = first; i; i = i->next){\n    sum = sum + i->datum;\n}\nreturn sum;"
      ]
    },
    {
      "group": 182,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "if (first == 0) {\nreturn 0;}\nelse {\nint sum;\nNode *n = first->next;\nfor (Node *p = first; p != 0; p = n) {\n if (n->next == 0) {\n    break;\n }\n  sum += p->datum;\n  n = p->next;\n  }\n  return sum;\n  "
      ]
    },
    {
      "group": 183,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "int sum = 0;\nif (!first) {\n    return sum;\n}\nelse {\n    for (Node *np = first; np; np = np->next){\n        sum += np->datum;\n    }\n    return sum;\n"
      ]
    },
    {
      "group": 184,
      "parsed": false,
      "num": 1,
      "submissions": [
        "if (first==last) return 0;\nint sum;\nauto temp = first;\nwhile(temp!=last){\n    sum+=temp->datum;\n    temp=temp->next;\n}\nsum+=temp->datum;\nreturn sum;"
      ]
    },
    {
      "group": 185,
      "parsed": false,
      "num": 1,
      "submissions": [
        "int sum = 0; \nfor (auto it = first; it != last; ++it) {\n    sum += it -> datum;\n}\nreturn sum;"
      ]
    },
    {
      "group": 186,
      "parsed": true,
      "num": 1,
      "submissions": [
        "int sum = 0;\nif (first == last) {\n    if(*first == 0) {\n        return 0;\n    }\n}\nfor (Node *n = first; n; n = n->next) {\n    sum += n->datum;\n}\n return sum;"
      ]
    },
    {
      "group": 187,
      "parsed": false,
      "num": 1,
      "submissions": [
        "Node * ptr = first;\n\nif (!ptr) {return 0}\n\nint sum = 0;\nwhile (ptr) {\n   sum += ptr->datum;\n   ptr = ptr->next; \n}\n\nreturn sum;"
      ]
    },
    {
      "group": 188,
      "parsed": true,
      "num": 1,
      "submissions": [
        "if (first == 0) {\n    return 0;\n}\nint count = 0;\nfor (int *ptr = first; ptr != last; ptr=ptr->next) {\n    count += *ptr;\n}\nreturn count;"
      ]
    },
    {
      "group": 189,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "Node * curr = first;\n  if(curr == 0) return 0;\n  int sum = 0;\n  \n  while(curr != 0){\n    sum += curr->datum;\n    curr = curr->next;\n  }\n \n  return sum;\n"
      ]
    },
    {
      "group": 190,
      "parsed": true,
      "num": 1,
      "submissions": [
        "int sum = 0;\nif(!first){return 0;}\nfor(Node *ptr = first; ptr; ptr->next){\nsum += *ptr;\n}\nreturn sum;"
      ]
    },
    {
      "group": 191,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if(first == 0) {\nreturn 0; \n}\nNode *temp = first; \nint count = 0; \nwhile(temp != 0) {\ncount += temp->datum; \ntemp->next; \n}\ndelete temp; \nreturn count; "
      ]
    },
    {
      "group": 192,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "int sum = 0;\nNode *temp = first;\n\nwhile(temp != 0){\n    sum ++;\n    temp = temp->next;\n}\n\nreturn sum;"
      ]
    },
    {
      "group": 193,
      "parsed": false,
      "num": 1,
      "submissions": [
        "if(first == last){\n    return 0;\n}\nint sumValue = 0;\nfor(Node * n = first, n != 0; n->next){\n    sumValue += n->datum;\n}\nreturn sumValue;"
      ]
    },
    {
      "group": 194,
      "parsed": false,
      "num": 1,
      "submissions": [
        "if (first == 0 && last == 0) {\n    return 0;\n}\nint sum = 0;\nelse {\n    Node *nodeptr = first;\n    while (nodeptr != 0) {\n        sum += nodeptr->datum;\n        nodeptr = nodeptr->next;\n    }\nreturn sum;"
      ]
    },
    {
      "group": 195,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "Node * p = first;\nif(first == 0)\n{\n    return 0;\n}\nelse\n{\n    int sum = 0;\n    while(p != 0)\n    {\n        sum += p->datum;\n        p = p->next;\n    }\n    return sum;\n}        "
      ]
    },
    {
      "group": 196,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if (first == 0) {\n    return 0;\n}\nint s = 0;\nNode * n = first;\ns += n->datum;\nwhile (n != last) {\n    n = n->next;\n    s += n->datum;\n}\nreturn s;"
      ]
    },
    {
      "group": 197,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "if(!first){\n    return 0;\n}\nint sum = 0;\nNode* n = first;\nwhile(n){\n    sum = n->datum = sum;\n    n = n->next;\n}\nreturn sum;"
      ]
    },
    {
      "group": 198,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "if(!first) return 0;\nint sum = 1;\nwhile(first != last) {\n    ++sum;\n    ++first;\n}\nreturn sum;"
      ]
    },
    {
      "group": 199,
      "parsed": true,
      "num": 1,
      "submissions": [
        "Node *n = first;\nint sum = 0;\nwhile(n){\n    sum = sum + *n;\n    n = n->next;\n}\nreturn sum;\n"
      ]
    },
    {
      "group": 200,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "Node* node = first;\nint maxs = 0;\nwhile (node != 0) {\nmaxs = maxs + (*node).datum;\nnode = (*node).next;}\nreturn maxs;"
      ]
    },
    {
      "group": 201,
      "parsed": true,
      "num": 1,
      "submissions": [
        "if(datum == 0){\n    return 0;\n}\nint sums = 0;\nwhile(next != 0){\n    sums += datum;\n}\nreturn sums;\n"
      ]
    },
    {
      "group": 202,
      "parsed": true,
      "num": 1,
      "submissions": [
        "if(first == 0 && last ==0) {\nreturn 0;\n}\nint sum = 0;\nNode* ptr = first; \nwhile (ptr != NULL) { \n        sum += ptr->dataum; \n        ptr = ptr->next; \n    } \n  \nreturn sum;"
      ]
    },
    {
      "group": 203,
      "parsed": true,
      "num": 1,
      "submissions": [
        "sum = 0; \nif(first == 0){ return sum; }\nfor(Node * i = first; i != 0; i = i->next){\nsum += i->datum; \n}\nreturn sum; \n"
      ]
    },
    {
      "group": 204,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "if (first == last) {\n    return 0;\n}\nint sum = 0;\nNode *current = first;\nfor (; current != last; current = current->next) {\n    sum += current->datum;\n}\nreturn sum;"
      ]
    },
    {
      "group": 205,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if(!first) return 0;\nif(first == last) return first->datum;\n\nint sum = 0;\nNode* it = first;\nwhile(it != last) {\n    sum += it->datum;\n    it = it->next;\n}\n\nreturn sum + last->datum;"
      ]
    },
    {
      "group": 206,
      "parsed": false,
      "num": 1,
      "submissions": [
        "if(first == last == 0) {\n    return 0;\n}\nelse{\n    int sum = 0;\n    for(Node *n = first; n; n = n->next) {\n        sum = sum + n->datum;\n    }\n    return sum"
      ]
    },
    {
      "group": 207,
      "parsed": false,
      "num": 1,
      "submissions": [
        "if (first == last || first == 0) {\n    return 0;\n}\nNode *n = first;\nint totalSum = 0;\nelse {\n    while (n) {\n        totalSum += n->datum;\n        n = n->next;\n    }\nreturn totalSum;"
      ]
    },
    {
      "group": 208,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if (first == 0) {\nreturn 1;\n}\nelse {\nint sum = 0;\nfor (Node *np = first; np; np->next) {\nsum += np->datum;\n}\nreturn sum;"
      ]
    },
    {
      "group": 209,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "int sum = 0;\nNode *n = first;\nif(first == 0) {\n   return 0;\n}\nelse {\n   while(n != 0) {\n       sum += n->datum;\n       n = n->next;\n   }\n   return sum;\n"
      ]
    },
    {
      "group": 210,
      "parsed": false,
      "num": 1,
      "submissions": [
        "if (first == 0) { return 0 };\nint sum = 0;\nfor (Node *np = first; *np; np = np->next) {\n    sum += np->datum;\n}\n\nreturn sum;"
      ]
    },
    {
      "group": 211,
      "parsed": false,
      "num": 1,
      "submissions": [
        "//list is empty\nif(first == 0)\n{\n    return 0;\n}\nnew Node * i = first;\nwhile (i != last)\n{\n    sum += i -> datum;\n    i = i -> next;    \n"
      ]
    },
    {
      "group": 212,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if (first == 0) {\n    return 0;\n    }\nelse {\n    Node *ptr = first;\n    int total = 0;\n    \n    while (ptr != 0) {\n        total = total + ptr->datum;\n    }\n    return total;\n    }\n    \n    "
      ]
    },
    {
      "group": 213,
      "parsed": true,
      "num": 1,
      "submissions": [
        "if (empty(first) == true) {\n    return 0;\n    }\nelse {\n    int count = 0\n    for (Node *node_ptr = first; node_ptr; node_ptr->next) {\n        count += node_ptr;\n        }\n    return count;\n}\n    \n"
      ]
    },
    {
      "group": 214,
      "parsed": false,
      "num": 1,
      "submissions": [
        "int sum = 0;\n      for (auto &i = first; i; i=i->next) {\n          sum += i->datum;\n      }\n      return sum;"
      ]
    },
    {
      "group": 215,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "Node* currNode = first;\nint sum = 0;\n//summing up n-1 datums in the list of size n\nwhile(currNode->next) {\n    sum += currNode->datum;\n    currNode = currNode->next;\n}\nsum += currNode->datum; //adding the last datum to the sum\nreturn sum;"
      ]
    },
    {
      "group": 216,
      "parsed": true,
      "num": 1,
      "submissions": [
        "sum = 0;\nfor (Node *np = first; np; np = np->next) {\nsum += np->datum;\n}\nreturn sum;"
      ]
    },
    {
      "group": 217,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if (!first && !last) {return 0;}\nelse {\n    Node* ptr = first;\n    int total = 0;\n    while (ptr != 0) {\n        total += ptr->datum;\n        ptr = ptr->next;\n    }\n    return total;\n"
      ]
    },
    {
      "group": 218,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if (first == last && first == 0){\nreturn 0;\n}\n\nNode *n = first;\nint sum = 0;\nwhile(n != 0){\n    sum += n->datum;\n    n = n->next;\n    }\n    \nreturn sum;"
      ]
    },
    {
      "group": 219,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if(!first){\n    return 0;\n}\nNode *begin = first;\nNode *end = last->next;\nint sum = 0;\nfor(begin; begin != end; begin = begin->next){\n    sum = sum + begin->datum; \n}\nreturn sum; \n    "
      ]
    },
    {
      "group": 220,
      "parsed": true,
      "num": 1,
      "submissions": [
        "if (!node) return 0;\nint sum = 0;\nwhile(!node) {\n    int sum = 0;\n    sum =+ node->datum;\n}\nreturn sum;"
      ]
    },
    {
      "group": 221,
      "parsed": false,
      "num": 1,
      "submissions": [
        "if (first == last == 0) {\n    return 0;\n}\nint total = 0;\nelse {\n    for (Node *np = first; np; np = np->next) {\n        total += np->datum;\n    }\n}\nreturn total;"
      ]
    },
    {
      "group": 222,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "if (!first && !last) {\n    return 0;\n}\nif (first == last) {\n    return first->datum;\n}\nint sum = 0;\nfor (Node *ptr = first; ptr != last; ptr = ptr->next) {\n    sum += ptr->datum;\n}\nreturn sum;"
      ]
    },
    {
      "group": 223,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "int returnVal = 0;\nfor(Node *ptr = first; ptr != last; ++ptr){\n    returnVal += ptr->datum;\n}\nreturnVal += last->datum;\n\nreturn returnVal;"
      ]
    },
    {
      "group": 224,
      "parsed": true,
      "num": 1,
      "submissions": [
        "Node* ptr = first;\nNode* next;\nint sum = 0;\nwhile(ptr != NULL){\n    next = ptr->next;\n    sum += ptr->datum;\n    ptr = next;\n}\nreturn sum;"
      ]
    },
    {
      "group": 225,
      "parsed": true,
      "num": 1,
      "submissions": [
        "int sum = 0;\nfor (Node *node_ptr = first; node_ptr; node_ptr = node_ptr->next) {\n    sum += node_ptr-datum;\n}\nreturn sum;"
      ]
    },
    {
      "group": 226,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "Node *n = first;\nint sum = 0;\nif(n == 0)\n    return 0;\nwhile(n!= last){\n    sum += n->datum;\n    n=n->next;\n    }\n    sum += n->datum;\nreturn sum;"
      ]
    },
    {
      "group": 227,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "if (first == 0) {\n    //list is empty\n    //instructions above say to return 0 when list is empty\n    return 0;\n}\nNode *item = first;\nint sum = first->datum;\nwhile (item->next != 0) {\n    item = item->next;\n    sum = item->datum;\n}\nreturn sum;"
      ]
    },
    {
      "group": 228,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "if(!first){\nreturn 0; \n}\nNode * ptr = first; \nint sum = 0; \nfor(int i = 0; ptr != last; i++){\n    sum = sum + ptr->datum;  \n    ptr = ptr->next; \n}\nreturn sum; "
      ]
    },
    {
      "group": 229,
      "parsed": true,
      "num": 1,
      "submissions": [
        "int sum = 0;\nfor(Node *n = first; n != 0; n->next){\n    sum += node->datum;\n}\nreturn sum;"
      ]
    },
    {
      "group": 230,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "int count = 0;\nif(!first)\n{\n    return 0;\n}\ncount = first->datum;\nNode *current = first;\nwhile(current->next)\n{\n    count = count + current->datum;\n    current = current->next;\n}\nreturn count;"
      ]
    },
    {
      "group": 231,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "int sum = 0;\nfor(const Node *i = first; i != 0; i=i->next) {\n    sum += i->datum;\n}\n\nreturn sum;"
      ]
    },
    {
      "group": 232,
      "parsed": true,
      "num": 1,
      "submissions": [
        "Node* ptr = new Node;\nptr = first;\nint sum = 0;\nwhile(ptr != NULL){\n    sum += ptr->datum;\n    ptr = ptr->next;\n}\nreturn sum;"
      ]
    },
    {
      "group": 233,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "Node *temp = new Node;\ntemp = first;\nint count = 0;\nwhile (temp != 0){\n    count += (*temp).datum;\n    temp = (*first).next;\n}\ndelete temp;\nreturn count;"
      ]
    },
    {
      "group": 234,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if(first == 0 && last == 0) {\n    return 0;\n}\nint total = 0;\nfor(Node *temp = first; temp; temp = temp->next) {\n    total += temp->datum; \n}\nreturn total;"
      ]
    },
    {
      "group": 235,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "    int sum = 0;\n    Node* temp = first; \n    while(!temp){\n        sum+= temp ->datum;\n        ++temp;\n    }\n    return sum;\n"
      ]
    },
    {
      "group": 236,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "int sum = 0; \nif(!first){return 0;}\nNode *ptr = first; \nwhile(ptr->next != 0){\n    sum += ptr->datum;\n}\nreturn sum; "
      ]
    },
    {
      "group": 237,
      "parsed": false,
      "num": 1,
      "submissions": [
        "//wait what?? It says to return 0 here but to return 1 up above. \"// Returns 0 if the list is empty.\" AND \" // Returns 1 if the list is empty.\" This is extremely concerning but i dont have time to go to the zoom. Im going to follow the most recent instructions in the RME right above\nNode *n = first;\nint sum = 0;\nif(n == 0){\n    return 0 //or 1 depending on the instructions\n}\nwhile(n -> next != last){\n    sum = sum + (n-> datum); //the sum or the \"product sum\"? another discrepency?\n    n = n -> next;\n}\nreturn sum;"
      ]
    },
    {
      "group": 238,
      "parsed": false,
      "num": 1,
      "submissions": [
        "int sum = 0;\nfor(Node * node_ptr = first; node_ptr; node_ptr = node_ptr->next){\n    sum+=node_ptr->datum'\n}\nreturn sum;"
      ]
    },
    {
      "group": 239,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "if(first == 0) {\n\treturn 0;\n}\nNode * n = first;\nint sumResult = 0;\nwhile(n) {\n\tsumResult = n->datum;\n\tn = n->next;\n}\nreturn sumResult;"
      ]
    },
    {
      "group": 240,
      "parsed": true,
      "num": 1,
      "submissions": [
        "Node *target = first;\nsum = 0;\nif(first == 0){\n    return 0;\n} else {\nwhile(target != 0){\n    sum+= target->datum;\n    target = target->next;\n    }\nreturn sum;\n"
      ]
    },
    {
      "group": 241,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if(first == 0 || last == 0){\n  return 0;\n}\nint sum = 0;\nfor(Node *p = first;p;p = p->next){\n   sum = sum+(p->datum);\n }\n return sum;\n  "
      ]
    },
    {
      "group": 242,
      "parsed": true,
      "num": 1,
      "submissions": [
        "int tot;\nNode *ptr = new Node;\n*ptr = first;\nif (ptr == 0) {\n    return 0;\n    }\nelse {\nfor (;ptr != 0; ptr = ptr->next) {\ntot += ptr->datum;\n}\nreturn tot;\n"
      ]
    },
    {
      "group": 243,
      "parsed": false,
      "num": 1,
      "submissions": [
        "if (first == 0) {\n    return 0;\n}\n\nint total = 0;\nfor (Node* p = first;; p++) {\n    total += p->datum;\n    \n    if (p == last) {\n        break;\n    }\n}\n\nreturn total;"
      ]
    },
    {
      "group": 244,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "if(first == 0){\n    return 0\n}\nint sum = 0;\nfor(Node *n = first; n; n = n->next){\n    sum += 1;\n}\nreturn sum;"
      ]
    },
    {
      "group": 245,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "if (!first) {\n    return 0;\n}\nif (first == last) {\n    return first->datum;\n    }\nint totalsum = 0;\nNode* ptr = first;\nwhile (ptr->next != 0) {\n    totalsum += ptr->datum;\n    ptr = ptr->next;\n"
      ]
    },
    {
      "group": 246,
      "parsed": false,
      "num": 1,
      "submissions": [
        "Node *n = new Node;\nif (!n) {\n    return 0;\n}\nfor (n = first; n; n = n->next;){\n    sum = n->left->datum + n->right->datum;\n}\nreturn sum; "
      ]
    },
    {
      "group": 247,
      "parsed": true,
      "num": 1,
      "submissions": [
        "if (first = 0){\n    return 0;\n}\nint sum = 0;\nfor (Node *node_ptr = first; node_ptr != last; node_ptr = node_ptr->next){\n    sum += node->datum;\n}\nreturn sum;"
      ]
    },
    {
      "group": 248,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "\nNode *node = first;\nif (first == 0 && last == 0) {\nreturn 0;\n}\nint sumN = 0;\nwhile (node!= 0) {\n    sumN = sumN + node->datum;\n    node = node->next;\n}\n    return sumN;"
      ]
    },
    {
      "group": 249,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if (first == 0)\n    return 0;\n\nint runsum = 0\nNode* trav = first;\nwhile(trav != last->next) {\n    runsum += trav->datum;\n    trav = trav->next;\n}\n\nreturn runsum;"
      ]
    },
    {
      "group": 250,
      "parsed": false,
      "num": 1,
      "submissions": [
        "if (!this->first) {\n        return 0;\n\t}\n    int sum{0};\n\n    for (Node* i = first; i->next != 0 ; i = i->next)\n    {\n        sum += i->datum;\n    }\n    return sum;"
      ]
    },
    {
      "group": 251,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "if (first == 0) {\n    return 0;\n}\nif (first == last) {\n    return first->datum;\n}\nint sum = 0;\nfor (Node *np = first; np != last; np = np->next) {\n    sum += np->datum;\n}\nreturn sum;"
      ]
    },
    {
      "group": 252,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "int s=0;\nif (!first) {\n    return 0; \n}\nfor (Node *n = first; n; n = n->next) {\n    s=s+(n->datum);\n}\nreturn s;"
      ]
    },
    {
      "group": 253,
      "parsed": false,
      "num": 1,
      "submissions": [
        "if(first == 0) return 0;\nint total = first->datum;\nfor(auto i = first->next; i = last; ++i){\n   total = total + i->datum;\n}\nreturn total;"
      ]
    },
    {
      "group": 254,
      "parsed": true,
      "num": 1,
      "submissions": [
        "if(!first) return 0;\nint sum = 0;\nfor(Node p = first; p != 0; p = p->next){\n    sum += p->datum;\n}\nreturn sum;"
      ]
    },
    {
      "group": 255,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if (first == 0) { return 0; }\nNode *ptr = first;\nint sum = 0;\nwhile (ptr != 0) {\n    sum += ptr->datum;\n    ptr->next;\n}\nreturn sum;\n"
      ]
    },
    {
      "group": 256,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "int total = 0;\nfor (Node* it = first; it != last; it = it->next){\n    total += it->datum;\n}\ntotal += last->datum;\nreturn total;"
      ]
    },
    {
      "group": 257,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if (first == 0) {\n    return 0;\n} else {\n    int sum = 0;\n    for (Node *f = first; f; f = f->next) {\n    sum = sum + f->datum;\n    }\n    return sum;\n"
      ]
    },
    {
      "group": 258,
      "parsed": true,
      "num": 1,
      "submissions": [
        "int sumz = 0;\nwhile(prev != 0){\n    sumz += prev->datum;\n    prev = prev-> next;\n    }\nreturn sumz;"
      ]
    },
    {
      "group": 259,
      "parsed": true,
      "num": 1,
      "submissions": [
        "if (!first) { // equivalent of first->datum == 0\n    return 1;\n}\n\nNode *i = first;\nint sumCounter = 0;\nwhile (i != 0) {\n    sum += i->datum;\n    i = i->next;\n}\n\nreturn sum;\n"
      ]
    },
    {
      "group": 260,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "int sum = 0;\n        if (first == 0 && last == 0)\n        {\n            return 0;\n        }\n        else\n        {\n            for (Node* p = first; p != 0; p = p->next) {\n                sum++;\n            }\n            return sum;\n        "
      ]
    },
    {
      "group": 261,
      "parsed": false,
      "num": 1,
      "submissions": [
        "int sum = 0;\nfor (Node* n = first; n; n = n->next;) {\n    sum += n->datum;\n}\nreturn sum;"
      ]
    },
    {
      "group": 262,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if (first == 0 || last == 0) {\n    return 0;\n}\nNode *n = new Node;\nn = first;\nint total = 0;\nwhile (n->next != 0) {\n    total += n->datum;\n}\nreturn total;"
      ]
    },
    {
      "group": 263,
      "parsed": true,
      "num": 1,
      "testCasesPassed": true,
      "runtimeEvent": false,
      "submissions": [
        "if(first == 0) { return 0; }\nelse {\n    int sum = 0;\n    Node* n = first;\n    while(n != 0) {\n        sum += n->datum;\n        n = n->next;\n    }\n    return sum;\n"
      ]
    },
    {
      "group": 264,
      "parsed": true,
      "num": 1,
      "testCasesPassed": false,
      "runtimeEvent": true,
      "submissions": [
        "if (!first) {\n    return 0;\n}\nint sum;\nfor (Node* n = first; n; n = n->next) {\n    sum += n->datum;\n}\nreturn sum;"
      ]
    },
    {
      "group": 265,
      "parsed": true,
      "num": 1,
      "submissions": [
        "int sum = 0; \nfor(Node * ptr = first; first != last ; ptr = ptr->next) {\n    sum += ptr->datum;\n}\nsum += ptr->datum;\nreturn sum;"
      ]
    },
    {
      "group": 266,
      "parsed": false,
      "num": 1,
      "submissions": [
        "Node* temp = first;\nint sum = 0;\nwhile(temp != 0){\n    sum += temp->datum;\n    temp = temp->next;\n}\nreturn sum};"
      ]
    }
  ]
}