<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>

    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">

    <link rel="stylesheet" href="matlab.css">

    <!-- jQuery library -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>

    <!-- Latest compiled JavaScript -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>

    <script src="matlab_parser.js"></script>
    <script src="matlab_util.js"></script>
</head>
<body>
<div class="container-fluid">
    <div class="row">
        <div class="col-sm-4" style="background-color:lavender;">
            <ul class="list-group" id = "vars"></ul>
        </div>
        <div class="col-sm-8" style="background-color:lavenderblush;">
            <h1>MatLabster</h1>
            <p>This is some text.</p>
            <label for="expression_in">Expression:</label>
            <textarea class="form-control" rows="2" id="expression_in"></textarea>
            <div class="container" id = "visualization">

            </div>
        </div>
    </div>

</div>

</body>

<script>
    document.getElementById("visualization").innerHTML = "test";
    function random_color() {
        // http://stackoverflow.com/questions/1484506/random-color-generator-in-javascript
        var letters = '6789ABCDEF';
        var color = '#';
        for (var i = 0; i < 6; i++ ) {
            color += letters[Math.floor(Math.random() * 10)];
        }
        return color;
    }

    var MatrixHistory = Class.extend({
       _name: "MatrixHistory",

        init : function () {
            this.color = toColor(this, "6789ABCDEF");
        },

        visualize_html : Class._ABSTRACT
    });

    MatrixHistory.AppendRows = MatrixHistory.extend({
        _name: "MatrixHistory.AppendRows",

        init : function(rows) {
            this.initParent();
            this.rows = rows;
        },

        visualize_html : function(dest) {
            var table = $("<table></table>");
            table.addClass("matlab-table");
            table.css("background-color", this.color);

            var rows = this.rows;
            for (var i = 0; i < rows.length; ++i) {
                var tr = $("<tr></tr>");
                table.append(tr);
                var td = $("<td></td>");
                tr.append(td);
                rows[i].visualize_html(td);
            }
            dest.append(table);
        }
    });

    MatrixHistory.AppendCols = MatrixHistory.extend({
        _name: "MatrixHistory.AppendCols",

        init : function(cols) {
            this.initParent();
            this.cols = cols;
        },

        visualize_html : function(dest) {
            var cols = this.cols;
            if (cols.length == 1) {
                // Single element row - just visualize the element, not as a row
                cols[0].visualize_html(dest);
            }
            else {
                var table = $("<table></table>");
                table.addClass("matlab-table");
                table.css("background-color", this.color);
                var tr = $("<tr></tr>");
                table.append(tr);

                for (var i = 0; i < cols.length; ++i) {
                    var td = $("<td></td>");
                    tr.append(td);
                    cols[i].visualize_html(td);
                }
                dest.append(table);
            }
        }
    });

    // TODO: make this meaningfully different from AppendCols
    MatrixHistory.Range = MatrixHistory.extend({
        _name: "MatrixHistory.Range",

        init : function(range) {
            this.initParent();
            this.range = range;
        },

        visualize_html : function(dest) {
            var range = this.range;
            if (range.length == 1) {
                // Single element row - just visualize the element, not as a row
                range[0].visualize_html(dest);
            }
            else {
                var table = $("<table></table>");
                table.append('<svg><defs><marker id="arrow" markerWidth="10" markerHeight="10" refx="9" refy="3" orient="auto" markerUnits="strokeWidth"> <path d="M0,0 L0,6 L9,3 z" fill="#000" /> </marker> </defs><g transform="translate(-10,0)"><line x1="22" y1="25" x2="100%" y2="25" stroke="#000" stroke-width="1" marker-end="url(#arrow)" /></g> </svg>');

                table.addClass("matlab-range");
                table.css("background-color", this.color);
                var tr = $("<tr></tr>");
                table.append(tr);

                for (var i = 0; i < range.length; ++i) {
                    var td = $("<td></td>");
                    tr.append(td);

                    // NOTE: The numbers themselves in a range are calculated and thus
                    //       have a history, although in the future it may be useful to
                    //       somehow show the history of the start, step, and end.
//                    range[i].visualize_html(td);
                    var temp = $("<div></div>");
                    temp.addClass("matlab-scalar");
                    var tempSpan = $("<span></span>");
                    tempSpan.html(range[i]);
                    temp.append(tempSpan);
                    td.append(temp);
                }
                dest.append(table);
            }
        }
    });

    MatrixHistory.Scalar = MatrixHistory.extend({
        _name: "MatrixHistory.Scalar",

        init : function(value) {
            this.initParent();
            this.value = value;
        },

        visualize_html : function(dest) {
            var temp = $("<div></div>");
            temp.addClass("matlab-scalar");
            var tempSpan = $("<span></span>");
            tempSpan.html(this.value);
            temp.append(tempSpan);
            dest.append(temp);
        }
    });

//    MatrixHistory.Raw = MatrixHistory.extend({
//        _name: "MatrixHistory.Raw",
//
//        init : function(data) {
//            this.initParent();
//            this.data = data;
//        },
//
//        visualize_html : function(dest) {
//            var table = $("<table></table>");
//            table.addClass("matlab-table");
//            table.css("background-color", this.color);
//            for (var r = 1; r <= this.numRows(); ++r) {
//                var tr = $("<tr></tr>");
//                table.append(tr);
//                for (var c = 1; c <= this.numCols(); ++c) {
//                    var td = $("<td></td>");
//                    if (this.matrixIndex.isSelected(r, c)){
//                        td.addClass("selected");
//                    }
//                    var temp = $("<div></div>");
//                    temp.addClass("matlab-scalar");
//                    var tempSpan = $("<span></span>");
//                    tempSpan.html(this.numRows().at(r,c));
//                    temp.append(tempSpan);
//                    td.html(temp);
//                    tr.append(td);
//                }
//
//            }
//
//            dest.append(table);
//        }
//    });

    MatrixHistory.MatrixIndex = MatrixHistory.extend({
        _name: "MatrixHistory.MatrixIndex",

        init : function(matrixIndex) {
            this.initParent();
            this.matrixIndex = matrixIndex;
        },

        visualize_html : function(dest) {
            var source = this.matrixIndex.source();
            var table = $("<table></table>");
            table.addClass("matlab-table");
            table.css("background-color", this.color);
            for (var r = 1; r <= source.numRows(); ++r) {
                var tr = $("<tr></tr>");
                table.append(tr);
                for (var c = 1; c <= source.numCols(); ++c) {
                    var td = $("<td></td>");
                    if (this.matrixIndex.isSelected(r, c)){
                        td.addClass("selected");
                    }
                    var temp = $("<div></div>");
                    temp.addClass("matlab-scalar");
                    var tempSpan = $("<span></span>");
                    tempSpan.html(source.at(r,c));
                    temp.append(tempSpan);
                    td.html(temp);
                    tr.append(td);
                }

            }

            dest.append(table);
        }
    });



    var Matrix = Class.extend({
        _name: "Matrix",

        //Static functions
        append_cols : function(mats) {
            mats = mats.map(function(m){return m.matrixValue()});
            var rows = mats[0].rows;
            return Matrix.instance(
                    mats[0].rows,
                    mats.reduce(function(prev, current){
                        return prev + current.cols;
                    },0),
                    mats.reduce(function(newData, mat){
                        if (mat.rows !== rows){
                            throw {message: "Mismatched matrix number of rows."};
                        }
                        newData.pushAll(mat.data);
                        return newData;
                    }, []),
                    MatrixHistory.AppendCols.instance(mats.map(function(mat){
                        return mat.history;
                    }))
            );
        },
        append_rows : function(mats) {
            mats = mats.map(function(m){return m.matrixValue()});
            var newCols = [];
            var cols = mats[0].cols;
            var newRows = 0;
            for(var i = 0; i < cols; ++i) {
                newCols.push([]);
            }
            for(var i = 0; i < mats.length; ++i) {
                var mat = mats[i];
                newRows += mat.rows;
                if (mat.cols !== cols) {
                    throw {message: "Mismatched matrix number of columns."};
                }
                for(var c = 0; c < cols; ++c) {
                    for(var r = 0; r < mat.rows; ++r) {
                        newCols[c].push(mat.at(r+1, c+1));
                    }
                }
            }
            var newData = [].concat.apply([], newCols);
            return Matrix.instance(newRows, cols, newData,
                MatrixHistory.AppendRows.instance(mats.map(function(mat){
                    return mat.history;
                }))
            );
        },
        scalar : function(value) {
            return Matrix.instance(1, 1, [value], MatrixHistory.Scalar.instance(value));
        },

        //Member functions
        init : function(rows, cols, data, history){
            assert(rows*cols === data.length, "rows: " + rows + "cols: " + cols + " data: " + data.length);
            this.rows = rows;
            this.cols = cols;
            this.height = rows;
            this.width = cols;
            this.data = data;
            this.history = history || null;

            this.color = toColor([this.rows, this.height, this.data], "6789ABCDEF");
        },
        toString : function() {
            return "Rows: " + this.rows + " Cols: " + this.cols + "\nData: " + JSON.stringify(this.data);
        },
        numRows : function() {
            return this.rows;
        },
        numCols : function() {
            return this.cols;
        },
        at : function(row, col) {
            row = row - 1;
            col = col - 1;
            return this.data[col * this.rows + row]
        },
        at0 : function(row, col){
            return this.data[col * this.rows + row]
        },
        setAt : function(row, col, scalar) {
            row = row - 1;
            col = col - 1;
            this.data[col * this.rows + row] = scalar;
        },
        setAt0 : function(row, col, scalar){
            this.data[col * this.rows + row] = scalar;
        },
        getRaw : function (index) {
            return this.data[index - 1];
        },
        getRaw0 : function (index) {
            return this.data[index];
        },
        setRaw : function (index, scalar) {
            this.data[index - 1] = scalar;
        },
        setRaw0 : function(index, scalar) {
            this.data[index] = scalar;
        },
        length : function() {
            return this.rows * this.cols;
        },
        scalarValue : function() {
            return this.data[0];
        },
        matrixValue : function() {
            return this;
        },
        contains : function(value) {
            return this.data.contains(value);
        },
        visualize_html : function(dest) {
//            if (this.history){
//                this.history.visualize_html(dest);
//                return;
//            }

            var table = $("<table></table>");
            table.addClass("matlab-table");
            table.css("background-color", this.color);
            for (var r = 1; r <= this.numRows(); ++r) {
                var tr = $("<tr></tr>");
                table.append(tr);
                for (var c = 1; c <= this.numCols(); ++c) {
                    var td = $("<td></td>");
                    var temp = $("<div></div>");
                    temp.addClass("matlab-scalar");
                    var tempSpan = $("<span></span>");
                    tempSpan.html(this.at(r,c));
                    temp.append(tempSpan);
                    td.html(temp);
                    tr.append(td);
                }
            }

            dest.append(table);
        }

    });

    var LogicalMatrix = Matrix.extend({
        _name : "LogicalMatrix"
    });

    var MatrixIndex = Class.extend({
        _name: "MatrixIndex",

        instance : function(variable, indices){
            if (indices.length > 1) {
                return this._parent.instance.apply(this.Coordinates, arguments);
            }
            var index = indices[0];
            if (isA(index, LogicalMatrix)) {
                return this._parent.instance.apply(this.Logical, arguments);
            }
            else{
                return this._parent.instance.apply(this.Matrix, arguments);
            }
        },

        init : function(variable) {
            this.variable = variable;
            this.history = MatrixHistory.MatrixIndex.instance(this);
        },
        source : function () {
            return this.variable.value;
        },

        length : function() {
            return this.numRows() * this.numCols();
        },

        matrixValue : function(){
            var copyData = [];
            for(var i = 1; i <= this.length(); ++i) {
                copyData.push(this.getRaw(i));
            }
            return Matrix.instance(this.numRows(), this.numCols(), copyData);
        },

        visualize_html : function(dest){
            this.history.visualize_html(dest);
        },

        numRows: Class._ABSTRACT,
        numCols: Class._ABSTRACT,
        getRaw : Class._ABSTRACT,
        setRaw : Class._ABSTRACT,

        history: Class._ABSTRACT
    });

    MatrixIndex.Coordinates = MatrixIndex.extend({
        _name: "MatrixIndex.Coordinates",

        init : function(variable, indices) {
            this.initParent(variable);
            if (indices.length > 2) {
                throw {message: "Too many indices. Only 2D arrays are supported."};
            }
            this.selectedRows = indices[0];
            this.selectedCols = indices[1];

            // HACK that makes life much easier
            if (this.selectedRows.what === "colon_exp") {
                var allRows = [];
                for(var i = 1; i <= this.source().numRows(); ++i) {
                    allRows.push(i);
                }
                this.selectedRows = Matrix.instance(allRows.length, 1, allRows);
            }
            if (this.selectedCols.what === "colon_exp") {
                var allCols = [];
                for(var i = 1; i <= this.source().numCols(); ++i) {
                    allCols.push(i);
                }
                this.selectedCols = Matrix.instance(allCols.length, 1, allCols);
            }

            // Check that all indices are within bounds
            for(var i = 0; i < this.selectedRows.length(); ++i){
                var rowIndex = this.selectedRows.getRaw0(i);
                if (rowIndex < 1 || rowIndex > this.source().numRows()){
                    throw {message: "Row index " + rowIndex + " is out of bounds."};
                }
            }
            for(var i = 0; i < this.selectedCols.length(); ++i){
                var colIndex = this.selectedCols.getRaw0(i);
                if (colIndex < 1 || colIndex > this.source().numCols()){
                    throw {message: "Column index " + colIndex + " is out of bounds."};
                }
            }
        },
        isSelected : function(r, c){
            return (this.selectedRows.what === "colon_exp" || this.selectedRows.contains(r)) &&
                   (this.selectedCols.what === "colon_exp" || this.selectedCols.contains(c));
        },
        assign : function(mat){
            var nr1 = this.numRows();
            var nc1 = this.numCols();
            var nr2 = mat.numRows();
            var nc2 = mat.numCols();
            // For coordinate indexing, the dimensions must match exactly,
            // except that rows/cols may be switched around if one of them is 1.
            // (I hate you matlab)
            if (!(nr1 == nr2 && nc1 == nc2 || (nr1 === 1 || nc1 === 1) && nr1 == nc2 && nc1 == nr2)){
                throw {message: "Subscripted assignment dimension mismatch. The left hand side indexing expression" +
                " gives a " + nr1 + "x" + nc1 + " while the right hand side is a " + nr2 + "x" + nc2 + "."}
            }

            for(var i = 1; i <= mat.length(); ++i) {
                this.setRaw(i, mat.getRaw(i));
            }
            this.variable.refresh();
        },
        numRows : function() {
            return this.selectedRows.what === "colon_exp" ? this.source.numRows() : this.selectedRows.length();
        },
        numCols : function() {
            return this.selectedCols.what === "colon_exp" ? this.source.numCols() : this.selectedCols.length();
        },
        getRaw : function(index) {
            // AHHHH this math kill me now
            var index0 = index - 1;
            var whichCol0 = integerDivision(index0, this.numRows());
            var whichRow0  = index0 % this.numRows();
            return this.source().at(this.selectedRows.getRaw(whichRow0+1), this.selectedCols.getRaw(whichCol0+1));
        },
        setRaw : function(index, scalar) {
            var index0 = index - 1;
            var whichCol0 = integerDivision(index0, this.numRows());
            var whichRow0  = index0 % this.numRows();
            this.source().setAt(this.selectedRows.getRaw(whichRow0+1), this.selectedCols.getRaw(whichCol0+1), scalar);
        }

    });

    MatrixIndex.Logical = MatrixIndex.extend({
        _name: "MatrixIndex.Logical",

        init : function(variable, indices) {
            this.initParent(variable);
            this.indexMatrix = indices[0];
        },

        isSelected : function(r, c){
            return this.indexMatrix.at(r,c) === 1;
        }
    });

    MatrixIndex.Matrix = MatrixIndex.extend({
        _name: "MatrixIndex.Matrix",

        init : function(variable, indices) {
            this.initParent(variable);
            this.indexMatrix = indices[0];
        },

        isSelected : function(r, c){
            return this.indexMatrix.contains((c-1) * this.source().rows + r);
        }
    });

    var Variable = Class.extend({
        _name: "Variable",

        init: function(identifier, value){
            this.value = value;
            this.identifier = identifier;
            this.elem = $('<li class="list-group-item"><span class="badge">'+identifier+'</span></li>');
            var dest = $("<span class='matlab-var-holder'></span>");
            this.elem.prepend(dest);

            // Show initial value
            this.refresh();
        },
        htmlElem : function(){
            return this.elem;
        },
        refresh : function() {
            var holder = this.elem.find(".matlab-var-holder");
            holder.empty();
            this.value.visualize_html(holder);
        },
        setValue : function(value) {
            this.value = value;
            this.refresh();
        },
        matrixValue : function() {
            return this.value.matrixValue();
        },
        visualize_html(dest){
            return this.value.visualize_html(dest);
        }
    });

    var CodeConstruct = Class.extend({

        init : function(src){
            this.src = src;
        },

        delegate : function(src) {
            if(src["what"] === "assignment"){
                return this.Assignment;
            }
            else if(src["what"] === "assignment_call"){
                return this.AssignmentCall;
            }
            else{
                return this.Expression;
            }
        }

    });

    var Expression = CodeConstruct.Expression = Class.extend({

        createAndEvaluate : function(src) {
            var exp = Expression.instance(src);
            return exp.evaluate();
        },

        // Map from "what" key in src generated by grammar to
        // the name of the subclass in the code.
        grammarToSubclass : {
            "matrix_exp": "Matrix",
            "row_exp": "Row",
            "range_exp": "Range",
            "or_exp": "MatrixOr",
            "and_exp": "MatrixAnd",
            "eq_exp": "Equality",
            "rel_exp": "Relational",
            "add_exp": "Add",
            "mult_exp": "Mult",
            "unary_exp": "Unary",
            "postfix_exp": "Postfix",
            "call_exp": "Call",
            "colon_exp": "Colon",
            "integer": "Literal",
            "identifier": "Identifier"
        },

        // Subclass delegation
        delegate : function(src) {
            assert(this.grammarToSubclass.hasOwnProperty(src["what"]));
            return this[this.grammarToSubclass[src["what"]]];
        },

        // This will ALWAYS yield an object of Matrix type.
        // It is Matlab, after all :P
        evaluate : Class._ABSTRACT

    });

    Expression.Matrix = Expression.extend({
        _name : "Expression.Matrix",

        evaluate : function() {
            var src = this.src;
            this.rows = src["rows"].map(Expression.instance, Expression);
            var rowValues = this.rows.map(function(r){
                return r.evaluate();
            });
            return Matrix.append_rows(rowValues);
        }
    });

    Expression.Row = Expression.extend({
        _name : "Expression.Row",

        evaluate : function() {
            var src = this.src;
            this.cols = src["cols"].map(Expression.instance, Expression);
            var colValues = this.cols.map(function(c){
                return c.evaluate();
            });
            return Matrix.append_rows(colValues);
        }
    });

    Expression.Range = Expression.extend({
        _name : "Expression.Range",

        evaluate : function() {
            var src = this.src;
            var range = [];
            var x = Expression.createAndEvaluate(src.start).scalarValue();
            var end = Expression.createAndEvaluate(src.end).scalarValue();
            var step = src.step && Expression.createAndEvaluate(src.step).scalarValue() || 1;
            while (x <= end) {
                range.push(x);
                x += (step || 1);
            }
            return Matrix.instance(1, range.length, range, MatrixHistory.Range.instance(range));
        }
    });

    Expression.Call = Expression.extend({
        _name : "Expression.Call",

        evaluate : function() {
            var src = this.src;
            var receiver = Expression.createAndEvaluate(src["receiver"]);
            if (this.vars.hasOwnProperty(receiver.identifier)){
                // Matlab checks for variables first and trys to index them

                var args = exp["args"].map(this.evaluate_step, this);
                return MatrixIndex.instance(receiver, args);
            }
            else if (this.functions.hasOwnProperty(receiver.identifier)) {
                // Then try functions
            }
        }
    });

    var Evaluator = Class.extend({
        _name: "Evaluator",
        varArea: $("#vars"),

        functions : {

        },


        //Member functions
        init : function(){
            this.vis = [];
            this.vars = {};

        },
        evaluate_step : function(exp) {
            if (exp["what"] === "range_exp") {
                var range = [];
                var x = this.evaluate_step(exp.start).scalarValue();
                var end = this.evaluate_step(exp.end).scalarValue();
                var step = exp.step && this.evaluate_step(exp.step).scalarValue() || 1;
                while (x <= end) {
                    range.push(x);
                    x += (step || 1);
                }
                return Matrix.instance(1, range.length, range, MatrixHistory.Range.instance(range));
            }
            else if (exp["what"] === "matrix_exp") {
                var rows = exp["rows"].map(this.evaluate_step, this);
                return Matrix.append_rows(rows);
            }
            else if (exp["what"] === "row_exp") {
                var cols = exp["cols"].map(this.evaluate_step, this);
                return Matrix.append_cols(cols);
            }
            else if (exp["what"] === "integer") {
                return Matrix.scalar(exp["value"]);
            }
            else if (exp["what"] === "assignment") {
                var result = this.evaluate_step(exp["exp"]);
                var id = exp["identifier"].identifier;
                this.setVar(id, result.matrixValue());
                return {
                    // TODO this will become assignment visualization class thingy
                    visualize_html : function(dest) {
                        var wrapper = $("<div></div>");
                        wrapper.addClass("matlab-assignment");
                        var lhsElem = $("<div></div>");
                        lhsElem.html(id + "&nbsp;=&nbsp;");
                        wrapper.append(lhsElem);

                        var rhsElem = $("<div></div>");
                        result.visualize_html(rhsElem);
                        wrapper.append(rhsElem);

                        dest.append(wrapper);
                    }
                };
            }
            else if (exp["what"] === "assignment_call") {
                var result = this.evaluate_step(exp["exp"]);
                var lhs = this.evaluate_step(exp["call"]);
                lhs.assign(result);
                return {
                    // TODO this will become assignment visualization class thingy
                    visualize_html : function(dest) {
                        var wrapper = $("<div></div>");
                        wrapper.addClass("matlab-assignment");
                        var lhsElem = $("<div></div>");
                        lhs.visualize_html(lhsElem);
                        wrapper.append(lhsElem);

                        wrapper.append("&nbsp;=&nbsp;");

                        var rhsElem = $("<div></div>");
                        result.visualize_html(rhsElem);
                        wrapper.append(rhsElem);

                        dest.append(wrapper);
                    }
                };

            }
            else if (exp["what"] === "identifier") {
                var identifier = exp["identifier"];
                if (this.vars.hasOwnProperty(identifier)){
                    return this.vars[identifier];
                }
                else {
                    throw {message: "Cannot find variable " + identifier};
                }
            }
            else if (exp["what"] === "call_exp") {
                var receiver = this.evaluate_step(exp["receiver"]);
                if (this.vars.hasOwnProperty(receiver.identifier)){
                    // Matlab checks for variables first and trys to index them

                    var args = exp["args"].map(this.evaluate_step, this);
                    return MatrixIndex.instance(receiver, args);
                }
                else if (this.functions.hasOwnProperty(receiver.identifier)) {
                    // Then try functions
                }
            }
            else if (exp["what"] === "colon_exp") {
                return exp;
            }
        },
        updateVar : function(identifier){
            assert(this.vars.hasOwnProperty(identifier), "Internal Error: Can't find identifier " + identifier);
            var varData = this.vars[identifier];
            var holder = varData.varItem.find(".matlab-var-holder");
            holder.empty();
            varData.value.history.visualize_html(holder);
        },
        setVar : function(identifier, value) {
            if (this.vars.hasOwnProperty(identifier)){
                this.vars[identifier].setValue(value);
            }
            else{
                var v = Variable.instance(identifier, value);
                this.varArea.append(v.htmlElem())
                this.vars[identifier] = v;
            }
//            $(".matlab-table").each(function(){
//                $(this).css("background-color", random_color());
//            });
        }
    });

    function visualize(exp, dest){
        if (exp["what"] === "row_exp") {
            var cols = exp["cols"];
            if (cols.length == 1) {
                visualize(cols[0], dest);
            }
            else {
                var table = $("<table></table>");
                table.addClass("matlab-table");
                var tr = $("<tr></tr>");
                table.append(tr);

                for (var i = 0; i < cols.length; ++i) {
                    var td = $("<td></td>");
                    tr.append(td);
                    visualize(cols[i], td);
                }
                dest.append(table);
            }
        }
        else if (exp["what"] === "range_exp") {
            var range = [];
            var x = exp.start;
            while(x <= exp.end) {
                range.push(x);
                x += (exp.step || 1);
            }
//            dest.append(table_from_row(range));
        }
        else if (exp["what"] === "matrix_exp") {
            var table = $("<table></table>");
            table.addClass("matlab-table");

            var rows = exp["rows"];
            for (var i = 0; i < rows.length; ++i) {
                var tr = $("<tr></tr>");
                table.append(tr);
                var td = $("<td></td>");
                tr.append(td);
                visualize(rows[i], td);
            }
            dest.append(table);
        }
        else {
            var temp = $("<span></span>");
            temp.html(JSON.stringify(exp, null, 2));
            dest.append(temp);
        }
    }

    $(document).ready(function(){
        var exp_in_timeout;
        var evaluator = Evaluator.instance();

        $("#expression_in").bind("input", function () {
            var delay = 500; // ms
            alert("hi");
            clearTimeout(exp_in_timeout);
            var self = this;
            exp_in_timeout = setTimeout(function () {
                var src = $(self).val();
                $("#visualization").empty();
                try{
                    var exp = MATLAB_PARSER.parse(src.trim());
//                    visualize(exp, $("#visualization"));
                    var result = evaluator.evaluate_step(exp);
                    if (result) {
                        result.visualize_html($("#visualization"));
                        if (result.matrixValue){
                            evaluator.setVar("ans", result.matrixValue());
                        }
                        else{
//                            $(".matlab-table").each(function(){
//                                $(this).css("background-color", random_color());
//                            });
                        }
                    }
                }
                catch(err) {
                    $("#visualization").html(err.message);
                }
            }, delay)
        })
    });


//    var str = ""
//    for (var r = 0; r < rows.length; ++r) {
//        var row = rows[r];
//        for (var c = 0; c < row.length; ++c) {
//            str += row[c] + " ";
//        }
//        str += "\n";
//    }
//    return str;

</script>

</html>

