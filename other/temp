size_t strlen(const char *str) {
  const char *ptr = str;
  while (*ptr) {
    ++ptr;
  }
  return ptr - str;
}

char * strcpy(char *dst, const char *src) {
  char *dst_orig = dst;
  while(*dst++ = *src++);
  return dst_orig;
}

char *strncpy(char *dst, const char *src, size_t num) {
  char *dst_orig = dst;
  while (num > 0 && *src) {
  *dst++ = *src++;
    --num;
  }
  while(num > 0) {
  *dst++ = '\0';
    --num;
  }
  return dst_orig;
}

class strang {
  public:

    // CONSTRUCTORS

    strang()
: _size(0), _buffer_size(0), _data(new char[1]) {
  _data[0] = '\0';
}

strang(const strang &other)
: _size(other._size), _buffer_size(other._size + 1),
  _data(new char[_buffer_size]) {

  strcpy(_data, other._data);
}

strang(const strang &other, size_t pos, size_t len) {

  size_t possibleLen = strlen(other._data) - pos;
  if (possibleLen < len) {
    len = possibleLen;
  }

  _size = len;
  _buffer_size = len + 1;
  _data = new char[_buffer_size];

  const char *cstr = other._data + pos;
  for(size_t i = 0; i < len; ++i) {
    _data[i] = *cstr++;
  }
  _data[len] = '\0';

}

strang(const char *cstr)
: _size(0) {

  _size = strlen(cstr);

  // copy chars
  _buffer_size = _size + 1;
  _data = new char[_buffer_size];
  strcpy(_data, cstr);
}

strang(const char *cstr, size_t n)
: _size(n), _buffer_size(n + 1),
  _data(new char[_buffer_size]) {

  for(int i = 0; i < _size; ++i) {
    _data[i] = cstr[i];
  }
  _data[_size] = '\0';
}

strang(size_t n, char c)
: _size(n), _buffer_size(n + 1),
  _data(new char[_buffer_size]) {

  for(int i = 0; i < _buffer_size; ++i) {
    _data[i] = c;
  }
  _data[_size] = '\0';
}


// ASSIGNMENT OPERATORS

strang &operator=(const strang &rhs) {
  // copy swap
  strang copy(rhs);
  swap(copy);
}

strang &operator=(const char *cstr) {
  // construct swap
  strang copy(cstr);
  swap(copy);
}

strang &operator=(char c) {
  // construct swap
  strang copy(1,c);
  swap(copy);
}


// DESTRUCTOR
~strang() {
  delete[] _data;
}

// ITERATOR MEMBER FUNCTIONS
int begin() = @library_unsupported@;
void end() = @library_unsupported@;
void rbegin() = @library_unsupported@;
void rend() = @library_unsupported@;
void cbegin() = @library_unsupported@;
void cend() = @library_unsupported@;
void crbegin() = @library_unsupported@;
void crend() = @library_unsupported@;


// CAPACITY MEMBER FUNCTIONS
size_t size() const {
  return _size;
}

size_t length() const {
  return _size;
}

size_t max_size() const = @library_unsupported@;

size_t capacity() const {
  // _buffer_size is buffer capacity, but this counts the null char,
  // so the capacity to hold meaningful chars is one less
  return _buffer_size - 1;
}

void resize(size_t n) {
  resize(n, '/0');
}

void resize(size_t n, char c) {
  if (n < _size) {
  	// shorten string to only n
  }
  else {
		  // we have enough space, so just pad string with char c
  }
  else {


  private:
    size_t _size;
  size_t _buffer_size;
  char * _data;

  void swap(strang &other) {
    size_t temp_size = _size;
    _size = other._size;
    other._size = temp_size;

    size_t temp_buffer_size = _buffer_size;
    _buffer_size = other._buffer_size;
    other._buffer_size = temp_buffer_size;

    char * temp_data = _data;
    _data = other._data;
    other._data = temp_data;
  }
};